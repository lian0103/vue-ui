import { computed, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, resolveComponent, createBlock, createCommentVNode, renderSlot, createElementVNode, ref, watch, getCurrentInstance, onMounted, nextTick, getCurrentScope, onScopeDispose, toRefs, withModifiers, withDirectives, createVNode, vShow, toDisplayString, h, withCtx, onUpdated, createTextVNode, shallowRef, useSlots, reactive, onUnmounted, vModelDynamic, vModelText, Fragment, renderList, normalizeProps, mergeProps, inject, provide } from "vue";
var index$1 = "";
const __default__$z = {
  name: "GAvatar"
};
const _sfc_main$M = /* @__PURE__ */ Object.assign(__default__$z, {
  props: {
    imgUrl: {
      type: String,
      default: null
    },
    size: {
      type: String,
      default: "md"
    }
  },
  setup(__props) {
    const props = __props;
    const sizeType = ["sm", "md", "lg"];
    const styleComputed = computed(() => {
      return props.imgUrl ? {
        "background-image": `url(${props.imgUrl})`
      } : {};
    });
    const classComputed = computed(() => {
      let arr = [];
      arr.push(sizeType.includes("size") ? `size-${props.size}` : "size-md");
      if (!props.imgUrl) {
        arr.push("no-bg-img");
      }
      return arr;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-avatar", unref(classComputed)]),
        style: normalizeStyle(unref(styleComputed)),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
      }, null, 6);
    };
  }
});
_sfc_main$M.install = function(Vue) {
  Vue.component(_sfc_main$M.name, _sfc_main$M);
};
const _hoisted_1$u = /* @__PURE__ */ createElementVNode("div", { class: "textLine" }, null, -1);
const __default__$y = {
  name: "GButton"
};
const _sfc_main$L = /* @__PURE__ */ Object.assign(__default__$y, {
  props: {
    flatHover: {
      type: Boolean,
      default: true
    },
    flat: {
      type: Boolean
    },
    pill: {
      type: Boolean
    },
    type: {
      type: String,
      default: "second"
    },
    noBorder: {
      type: Boolean
    },
    icon: {
      type: String,
      default: "btnIconName"
    },
    iconNarrowPadding: {
      type: Boolean,
      default: false
    },
    iconPosition: {
      type: String,
      default: "left"
    },
    width: {
      type: Number
    },
    isLoading: {
      type: Boolean,
      default: false
    },
    iconClasses: {
      type: String
    }
  },
  setup(__props) {
    const {
      flat,
      flatHover,
      pill,
      type,
      noBorder,
      icon,
      width,
      isLoading,
      iconClasses
    } = __props;
    const classStr = computed(() => {
      if (flat) {
        return flatHover ? "gt-btn-flat" : "gt-btn-flat no-hover";
      }
      if (pill) {
        return "gt-btn-pill";
      }
      if (noBorder) {
        return "gt-btn-round-no-border";
      }
      return "gt-btn-round-no-border";
    });
    const typeStr = computed(() => {
      switch (type) {
        case "green": {
          return "gt-btn-green";
        }
        case "second": {
          return "gt-btn-second";
        }
        case "yellow": {
          return "gt-btn-yellow";
        }
        case "red": {
          return "gt-btn-red";
        }
        case "black": {
          return "gt-btn-black";
        }
        case "white": {
          return "gt-btn-white";
        }
        case "tag-bule": {
          return "gt-btn-tag-bule";
        }
      }
    });
    return (_ctx, _cache) => {
      const _component_g_loading_icon = resolveComponent("g-loading-icon");
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("button", {
        class: normalizeClass([[
          unref(classStr),
          unref(typeStr),
          __props.iconNarrowPadding ? "gt-icon-narrow-padding" : "",
          __props.icon && __props.iconPosition ? __props.iconPosition : ""
        ], "gt-btn"]),
        style: normalizeStyle(__props.width ? { width: `${__props.width}px` } : {})
      }, [
        __props.isLoading ? (openBlock(), createBlock(_component_g_loading_icon, { key: 0 })) : createCommentVNode("", true),
        __props.iconClasses && __props.iconPosition == "left" && !__props.isLoading ? (openBlock(), createBlock(_component_g_icon, {
          key: 1,
          name: __props.icon,
          style: { "margin-right": "4px" },
          classes: __props.iconClasses
        }, null, 8, ["name", "classes"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default"),
        __props.iconClasses && __props.iconPosition == "right" && !__props.isLoading ? (openBlock(), createBlock(_component_g_icon, {
          key: 2,
          name: __props.icon,
          style: { "margin-left": "4px" },
          classes: __props.iconClasses
        }, null, 8, ["name", "classes"])) : createCommentVNode("", true),
        _hoisted_1$u
      ], 6);
    };
  }
});
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$K = {
  name: "GLoadingIcon"
};
const _hoisted_1$t = { class: "gt-icon gt-icon-loading gt-icon-spin gt-loading-icon" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("i", _hoisted_1$t);
}
var GLoadingIcon = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$1]]);
const __default__$x = {
  name: "GIcon"
};
const _sfc_main$J = /* @__PURE__ */ Object.assign(__default__$x, {
  props: {
    name: {
      type: String,
      default: null
    },
    classes: {
      type: String
    },
    size: {
      type: String,
      default: "md"
    },
    style: {
      type: Object,
      default: () => {
        return {};
      }
    },
    fill: {
      type: String,
      default: "#55585E"
    }
  },
  setup(__props) {
    const props = __props;
    const componentKey = ref(0);
    const classesComputed = computed(() => {
      let arr = [];
      if (props.name) {
        arr.push("gt-icon");
        if (props.size) {
          arr.push(`gt-icon-${props.size}`);
        }
      }
      if (props.classes) {
        arr.push(props.classes);
      }
      return arr;
    });
    watch(
      () => props.classes,
      (val) => {
        componentKey.value = componentKey.value + 1;
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "gt-icon-wrapper",
        key: componentKey.value
      }, [
        createElementVNode("i", {
          style: normalizeStyle(__props.style),
          class: normalizeClass(unref(classesComputed))
        }, null, 6)
      ]);
    };
  }
});
_sfc_main$J.install = function(Vue) {
  Vue.component(_sfc_main$J.name, _sfc_main$J);
};
GLoadingIcon.install = function(Vue) {
  Vue.component(GLoadingIcon.name, GLoadingIcon);
};
_sfc_main$L.install = function(Vue) {
  Vue.component(_sfc_main$L.name, _sfc_main$L);
};
var _a;
const isClient = typeof window !== "undefined";
const isBoolean = (val) => typeof val === "boolean";
const isString = (val) => typeof val === "string";
const noop = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function unrefElement(elRef) {
  var _a2;
  const plain = unref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
_global[globalKey];
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$e.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$e.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = window2 && "ResizeObserver" in window2;
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref(0);
  const bottom = ref(0);
  const left = ref(0);
  const right = ref(0);
  const top = ref(0);
  const width = ref(0);
  const x = ref(0);
  const y = ref(0);
  function update() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  useResizeObserver(target, update);
  watch(() => unrefElement(target), (ele) => !ele && update());
  if (windowScroll)
    useEventListener("scroll", update, { passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Infinity,
    initialHeight = Infinity,
    listenOrientation = true
  } = options;
  const width = ref(initialWidth);
  const height = ref(initialHeight);
  const update = () => {
    if (window2) {
      width.value = window2.innerWidth;
      height.value = window2.innerHeight;
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation)
    useEventListener("orientationchange", update, { passive: true });
  return { width, height };
}
const _hoisted_1$s = ["onClick"];
const _hoisted_2$n = {
  key: 1,
  class: "checkbox-error-msg"
};
const __default__$w = {
  name: "GCheckbox"
};
const _sfc_main$I = /* @__PURE__ */ Object.assign(__default__$w, {
  props: {
    name: { default: null },
    formParentValue: { default: null },
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Boolean,
      default: false
    },
    label: {
      default: null
    },
    value: {
      default: null
    },
    parentValue: {
      default: null
    },
    handleChildClick: {
      default: null
    },
    type: {
      type: String,
      default: "GREEN"
    },
    validResult: {
      default: {}
    },
    handleValChange: {
      type: Function
    },
    checkedIcon: {
      type: String,
      default: () => "check"
    },
    controlMode: {
      type: Boolean,
      default: () => false
    }
  },
  emits: ["change", "update:modelValue"],
  setup(__props, { emit }) {
    const props = __props;
    const CheckboxEnum = {
      GREEN: "box-green",
      WHITE: "box-white"
    };
    const {
      name,
      formParentValue,
      disabled,
      label,
      value,
      parentValue,
      handleChildClick,
      type,
      validResult,
      handleValChange
    } = props;
    const { modelValue, checkedIcon } = toRefs(props);
    const errorMsg = computed(() => {
      var _a2;
      return (_a2 = validResult[name]) == null ? void 0 : _a2.message;
    });
    const isChecked = isBoolean(formParentValue) ? ref(formParentValue) : parentValue ? computed(() => parentValue == null ? void 0 : parentValue.value) : computed(() => modelValue.value);
    const classComputed = computed(() => {
      let arr = [
        "checkmark",
        CheckboxEnum[type.toUpperCase()] ? CheckboxEnum[type.toUpperCase()] : CheckboxEnum["GREEN"]
      ];
      if (isChecked.value || props.checkedIcon && props.checkedIcon != "check")
        arr.push("checked");
      if (disabled)
        arr.push("disabled");
      return arr;
    });
    const onClick = () => {
      if (!disabled && handleChildClick) {
        handleChildClick(value);
      }
      if (!disabled && !handleChildClick) {
        let val = !isChecked.value;
        emit("update:modelValue", val);
        emit("change", val);
        if (handleValChange) {
          isChecked.value = val;
          handleValChange(val, name);
        }
      }
    };
    const labelShow = computed(() => {
      if (label instanceof Function) {
        return label();
      } else {
        return label;
      }
    });
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", {
        onClick: withModifiers(onClick, ["prevent"]),
        class: "gt-checkbox"
      }, [
        createElementVNode("div", {
          class: normalizeClass(unref(classComputed))
        }, [
          withDirectives(createVNode(_component_g_icon, {
            class: "icon",
            classes: "fas fa-check",
            size: "md"
          }, null, 512), [
            [vShow, unref(checkedIcon) === "check" && unref(isChecked) || unref(checkedIcon) && unref(checkedIcon) !== "check"]
          ])
        ], 2),
        unref(labelShow) ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass([unref(disabled) ? "label-disabled" : "", "label select-none"])
        }, toDisplayString(unref(labelShow)), 3)) : createCommentVNode("", true),
        unref(errorMsg) ? (openBlock(), createElementBlock("span", _hoisted_2$n, toDisplayString(unref(errorMsg)), 1)) : createCommentVNode("", true)
      ], 8, _hoisted_1$s);
    };
  }
});
const _sfc_main$H = {
  name: "GCheckboxGroup",
  props: ["modelValue"],
  emits: ["update:modelValue", "change"],
  setup(props, { slots, emit }) {
    const handleChildClick = (val) => {
      if (Array.isArray(props.modelValue)) {
        let newArr = props.modelValue.includes(val) ? props.modelValue.filter((item) => item != val) : [...props.modelValue, val];
        emit("update:modelValue", newArr);
        emit("change", newArr);
        console.log("in~~~?");
      } else {
        emit("update:modelValue", [val]);
        emit("change", [val]);
      }
    };
    const genNodeTree = (item) => {
      return item.type.name === "GCheckbox" ? {
        ...item,
        props: {
          ...item.props,
          parentValue: computed(() => {
            var _a2;
            return (_a2 = props.modelValue) == null ? void 0 : _a2.includes(item.props.value);
          }),
          handleChildClick
        }
      } : {
        ...item,
        children: Array.isArray(item.children) ? item.children.map((cItem) => genNodeTree(cItem)) : item.children
      };
    };
    const validChilds = slots.default() ? slots.default().map((item) => genNodeTree(item)) : [];
    return () => h("div", validChilds);
  }
};
_sfc_main$I.install = function(Vue) {
  Vue.component(_sfc_main$I.name, _sfc_main$I);
};
_sfc_main$H.install = function(Vue) {
  Vue.component(_sfc_main$H.name, _sfc_main$H);
};
var Checkbox = { GCheckbox: _sfc_main$I, GCheckboxGroup: _sfc_main$H };
const __default__$v = {
  name: "GCollapseCard"
};
const _sfc_main$G = /* @__PURE__ */ Object.assign(__default__$v, {
  props: {
    isOpen: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const isOpenRef = ref(props.isOpen);
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      const _component_g_divider = resolveComponent("g-divider");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-collapse-card", isOpenRef.value ? "open" : ""])
      }, [
        createElementVNode("div", {
          class: "title-row",
          onClick: _cache[0] || (_cache[0] = ($event) => isOpenRef.value = !isOpenRef.value)
        }, [
          renderSlot(_ctx.$slots, "title"),
          createElementVNode("div", null, [
            _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 0 }) : (openBlock(), createBlock(_component_g_icon, {
              key: 1,
              name: "chevron-right",
              style: normalizeStyle({
                transform: `rotate(${isOpenRef.value ? "90" : "0"}deg)`,
                color: "#55585E"
              })
            }, null, 8, ["style"]))
          ])
        ]),
        withDirectives(createVNode(_component_g_divider, { style: "margin: 0px 0px 12px" }, null, 512), [
          [vShow, isOpenRef.value ? true : false]
        ]),
        createElementVNode("div", {
          class: normalizeClass(["content-row", isOpenRef.value ? "open" : ""])
        }, [
          createElementVNode("div", null, [
            renderSlot(_ctx.$slots, "content")
          ])
        ], 2)
      ], 2);
    };
  }
});
_sfc_main$G.install = function(Vue) {
  Vue.component(_sfc_main$G.name, _sfc_main$G);
};
const _sfc_main$F = {
  name: "GCollapseCardSection",
  setup(props, { slots, emit, expose }) {
    const validChilds = slots.default() ? slots.default().filter((item) => {
      return item.type.name == "GCollapseCard";
    }) : [];
    return () => h("div", { class: "gt-collapse-card-section" }, validChilds);
  }
};
_sfc_main$F.install = function(Vue) {
  Vue.component(_sfc_main$F.name, _sfc_main$F);
};
const _sfc_main$E = {
  __name: "GButtonClose",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$L), {
        round: "",
        noBorder: "",
        type: "white",
        class: "gt-button-close"
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$J), {
            name: "x",
            size: "md"
          })
        ]),
        _: 1
      });
    };
  }
};
const _hoisted_1$r = { class: "dialog-head" };
const _hoisted_2$m = { class: "dialog-footer" };
const __default__$u = {
  name: "GDialog"
};
const _sfc_main$D = /* @__PURE__ */ Object.assign(__default__$u, {
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    title: {
      type: String
    },
    align: {
      type: String,
      default: "left"
    },
    handleCallback: {
      type: Function,
      default: () => {
      }
    },
    mode: {
      type: String,
      default: "comfirm"
    },
    size: {
      type: String,
      default: "sm"
    },
    width: {
      type: Number,
      default: null
    },
    height: {
      type: Number,
      default: null
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const props = __props;
    const DialogEnum = {
      COMFIRM: "comfirm",
      DELETE: "delete",
      lg: { maxWidth: 1200, maxHeight: window.innerHeight - 200 },
      md: { maxWidth: 800, maxHeight: window.innerHeight - 200 },
      sm: { maxWidth: 360, maxHeight: window.innerHeight - 200 }
    };
    const maxWidth = computed(() => {
      var _a2;
      return props.width ? props.width : ((_a2 = DialogEnum[props.size]) == null ? void 0 : _a2.maxWidth) || 360;
    });
    const maxHeight = computed(() => {
      var _a2;
      return props.height ? props.height - 100 : ((_a2 = DialogEnum[props.size]) == null ? void 0 : _a2.maxHeight) || 820;
    });
    const dialogBodyIn = ref();
    const isScroll = ref(false);
    const handleComfirm = () => {
      props.handleCallback();
      emit("update:modelValue", false);
    };
    const handleCloseWrapper = (e) => {
      if (e.target.classList.contains("gt-dialog-wrapper")) {
        emit("update:modelValue", false);
      }
    };
    const handleClose = (e) => {
      emit("update:modelValue", false);
    };
    onUpdated(() => {
      var _a2;
      let bodyHight = Math.ceil((_a2 = dialogBodyIn.value.getBoundingClientRect()) == null ? void 0 : _a2.height);
      console.log(bodyHight, maxHeight.value);
      isScroll.value = bodyHight > maxHeight.value - 160 ? true : false;
    });
    return (_ctx, _cache) => {
      const _component_g_button = resolveComponent("g-button");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-dialog-wrapper", __props.modelValue ? "active" : ""]),
        onClick: handleCloseWrapper
      }, [
        createElementVNode("div", {
          class: normalizeClass(["gt-dialog", [`gt-text-${__props.align}`, __props.modelValue ? "active" : ""]]),
          onClick: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["prevent"])),
          style: normalizeStyle({
            maxWidth: unref(maxWidth) + "px"
          })
        }, [
          createElementVNode("div", _hoisted_1$r, [
            createTextVNode(toDisplayString(__props.title) + " ", 1),
            createVNode(_sfc_main$E, {
              class: "closeIcon",
              onClick: handleClose
            })
          ]),
          createElementVNode("div", {
            class: "dialog-body",
            style: normalizeStyle({
              maxHeight: unref(maxHeight) + "px",
              overflowY: isScroll.value ? "scroll" : "none"
            })
          }, [
            createElementVNode("div", {
              class: "dialog-body-in",
              ref_key: "dialogBodyIn",
              ref: dialogBodyIn
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 512)
          ], 4),
          createElementVNode("div", _hoisted_2$m, [
            createVNode(_component_g_button, {
              round: "",
              type: "white",
              class: "btn-cancel",
              onClick: handleClose
            }, {
              default: withCtx(() => [
                createTextVNode("\u53D6\u6D88")
              ]),
              _: 1
            }),
            __props.mode == DialogEnum.COMFIRM ? (openBlock(), createBlock(_component_g_button, {
              key: 0,
              round: "",
              onClick: handleComfirm
            }, {
              default: withCtx(() => [
                createTextVNode("\u78BA\u5B9A")
              ]),
              _: 1
            })) : (openBlock(), createBlock(_component_g_button, {
              key: 1,
              round: "",
              type: "red",
              onClick: handleComfirm
            }, {
              default: withCtx(() => [
                createTextVNode("\u522A\u9664")
              ]),
              _: 1
            }))
          ])
        ], 6)
      ], 2);
    };
  }
});
_sfc_main$D.install = function(Vue) {
  Vue.component(_sfc_main$D.name, _sfc_main$D);
};
const __default__$t = {
  name: "GDivider"
};
const _sfc_main$C = /* @__PURE__ */ Object.assign(__default__$t, {
  props: {
    horizontal: {
      type: Boolean,
      default: true
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: "100%"
    }
  },
  setup(__props) {
    const props = __props;
    const classComputer = computed(() => {
      return props.vertical ? ["vertical"] : ["horizontal"];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["g-divider", unref(classComputer)]),
        style: normalizeStyle(
          __props.vertical ? {
            height: __props.height
          } : {}
        )
      }, null, 6);
    };
  }
});
_sfc_main$C.install = function(Vue) {
  Vue.component(_sfc_main$C.name, _sfc_main$C);
};
const _hoisted_1$q = { class: "gt-download-icon" };
const _hoisted_2$l = { class: "iconBox" };
const __default__$s = {
  name: "GDownloadIcon"
};
const _sfc_main$B = /* @__PURE__ */ Object.assign(__default__$s, {
  props: {
    percent: {
      type: Number,
      default: 0
    },
    auto: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const { percent, auto } = __props;
    const percentNum = ref(percent);
    const styleComputed = computed(() => {
      return {
        background: `conic-gradient(#55585e 0 ${percentNum.value}%, #aaa 0 100%)`
      };
    });
    onMounted(() => {
      if (auto) {
        setInterval(() => {
          percentNum.value = percentNum.value + 10;
          if (percentNum.value > 100) {
            percentNum.value = 0;
          }
        }, 500);
      }
    });
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$q, [
        createElementVNode("div", {
          class: "pie",
          style: normalizeStyle(unref(styleComputed))
        }, null, 4),
        createElementVNode("div", {
          class: normalizeClass(["inner", percentNum.value >= 100 ? "completed" : ""])
        }, null, 2),
        createElementVNode("div", _hoisted_2$l, [
          percentNum.value < 100 ? (openBlock(), createBlock(_component_g_icon, {
            key: 0,
            name: "download_sm"
          })) : createCommentVNode("", true),
          percentNum.value >= 100 ? (openBlock(), createBlock(_component_g_icon, {
            key: 1,
            class: "white",
            name: "check"
          })) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
_sfc_main$B.install = function(Vue) {
  Vue.component(_sfc_main$B.name, _sfc_main$B);
};
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
const _hoisted_1$p = { class: "txt" };
const __default__$r = {
  name: "GDropdownItem",
  inheritAttrs: false,
  customOptions: {}
};
const _sfc_main$A = /* @__PURE__ */ Object.assign(__default__$r, {
  props: {
    option: {
      default: {}
    },
    label: {
      default: null
    },
    value: {
      default: null
    },
    icon: {
      default: false
    },
    parentValue: {
      default: null
    },
    handleChildClick: {
      default: () => {
      }
    }
  },
  emits: ["itemClick"],
  setup(__props, { emit }) {
    const props = __props;
    const isCurrentClick = ref(false);
    const isCurrent = computed(() => {
      var _a2, _b, _c;
      return ((_a2 = props.parentValue) == null ? void 0 : _a2.value) ? ((_b = props.parentValue) == null ? void 0 : _b.value) === props.option.value || ((_c = props.parentValue) == null ? void 0 : _c.value) === props.value : "";
    });
    const handleMouseLeave = () => {
      isCurrentClick.value = false;
    };
    const classComputed = computed(() => {
      let arr = [];
      if (isCurrentClick.value) {
        arr.push("curClicked");
      } else if (isCurrent.value) {
        arr.push("current");
      }
      return arr;
    });
    const handleClick = () => {
      emit("itemClick", { label: props.label, value: props.value });
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return __props.label ? (openBlock(), createElementBlock("div", {
        key: 0,
        onMouseleave: handleMouseLeave,
        class: normalizeClass(["gt-dropdown-item", unref(classComputed)]),
        onClick: _cache[0] || (_cache[0] = (e) => {
          e.stopPropagation();
          if (props.handleChildClick) {
            props.handleChildClick(__props.value || null);
          }
          handleClick();
          isCurrentClick.value = true;
        })
      }, [
        __props.icon ? (openBlock(), createBlock(_component_g_icon, {
          key: 0,
          class: "icon",
          name: "check"
        })) : createCommentVNode("", true),
        createElementVNode("span", {
          class: normalizeClass(unref(isCurrent) ? "text-main" : ""),
          style: normalizeStyle(__props.icon ? {} : { "padding-left": "14px" })
        }, [
          createElementVNode("div", _hoisted_1$p, toDisplayString(__props.label), 1)
        ], 6)
      ], 34)) : createCommentVNode("", true);
    };
  }
});
const _sfc_main$z = {
  name: "GDropdown",
  props: {
    name: { default: null },
    modelValue: {},
    formParentValue: { default: null },
    options: { type: Array },
    clicked: { type: Boolean, default: true },
    hover: { type: Boolean, default: false },
    icon: { type: Boolean, default: false },
    validResult: {
      default: {}
    },
    handleValChange: {
      type: Function
    },
    handleRulesValid: {
      type: Function
    }
  },
  emits: ["update:modelValue"],
  setup(props, { slots, emit }) {
    const id = v4();
    const rootObj = {
      [id]: shallowRef()
    };
    const isShow = ref(false);
    const isHover = ref(false);
    const hasSelect = ref(false);
    const valRef = props.formParentValue ? ref(props.formParentValue) : ref(props.modelValue);
    const errorMsg = computed(() => {
      var _a2;
      return (_a2 = props.validResult[props.name]) == null ? void 0 : _a2.message;
    });
    const slotOption = ref([]);
    const handleIsShow = () => {
      if (props.clicked) {
        let show = !isShow.value;
        isShow.value = show;
        isHover.value = false;
      }
    };
    const handleMouseenter = () => {
      if (props.hover) {
        isHover.value = true;
        isShow.value = true;
      }
    };
    const handleLeave = () => {
      if (props.hover) {
        isHover.value = false;
        isShow.value = false;
      }
    };
    const classHoverComputed = computed(() => {
      return props.hover && isHover.value ? "gt-dropdown gt-dropdown-hover" : "gt-dropdown";
    });
    const classShowComputed = computed(() => {
      let hadOpend = classShowComputed.value && classShowComputed.value.includes("tp-aniIn");
      return props.clicked && isShow.value ? "gt-dropdown-items tp-aniIn" : hadOpend ? "gt-dropdown-items tp-aniOut" : "gt-dropdown-items";
    });
    const labelComputed = computed(() => {
      return props.options && props.options.findIndex((item) => item.value === valRef.value) != -1 ? props.options.filter((item) => item.value === valRef.value)[0].label : slotOption.value.findIndex((item) => item.value === valRef.value) != -1 ? slotOption.value.filter((item) => item.value === valRef.value)[0].label : valRef.value;
    });
    const genNodeTree = (item) => {
      if (item.type.name === "GDropdownItem") {
        slotOption.value.push({
          label: item.props.label,
          value: item.props.value
        });
      }
      return item.type.name === "GDropdownItem" ? {
        ...item,
        props: {
          ...item.props,
          icon: props.icon,
          parentValue: computed(() => valRef.value),
          handleChildClick: (val) => {
            hasSelect.value = true;
            emit("update:modelValue", val);
            if (props.handleValChange) {
              props.handleValChange(val, props.name);
            }
            valRef.value = val;
          }
        }
      } : {
        ...item,
        children: Array.isArray(item.children) ? item.children.map((cItem) => genNodeTree(cItem)) : item.children
      };
    };
    const childs = computed(() => {
      var _a2, _b;
      let childArr = props.options ? (_a2 = props.options) == null ? void 0 : _a2.map((item) => {
        return h(_sfc_main$A, {
          option: item,
          label: item.label,
          value: item.value,
          icon: props.icon,
          parentValue: computed(() => valRef.value),
          handleChildClick: (val) => {
            hasSelect.value = true;
            emit("update:modelValue", val);
            if (props.handleValChange) {
              props.handleValChange(val, props.name);
            }
            valRef.value = val;
          }
        });
      }) : ((_b = slots == null ? void 0 : slots.default()) == null ? void 0 : _b.map((item) => genNodeTree(item))) || [];
      return childArr;
    });
    const textClassComputed = computed(() => {
      let arr = [];
      if (props.icon)
        arr.push("span-text");
      if (hasSelect.value)
        arr.push("text-main");
      return arr;
    });
    const eventHandle = () => {
      isShow.value = false;
    };
    const popupStyle = ref({});
    watch(
      () => isShow.value,
      (val, oldVal) => {
        var _a2;
        if (val && document.getElementsByTagName("html")[0]) {
          document.getElementsByTagName("html")[0].addEventListener("click", eventHandle, false);
          if (rootObj[id]) {
            popupStyle.value = {
              position: "absolute",
              top: "45px",
              left: "0px"
            };
          }
        } else {
          (_a2 = document.getElementsByTagName("html")[0]) == null ? void 0 : _a2.removeEventListener("click", eventHandle);
        }
      }
    );
    return () => h(
      "div",
      {
        ref: rootObj[id],
        class: classHoverComputed.value,
        onMouseenter: handleMouseenter,
        onMouseleave: handleLeave,
        onClick: (e) => {
          e.stopPropagation();
          handleIsShow();
        }
      },
      [
        h(
          "span",
          {
            class: "gt-dropdown-span"
          },
          [h("span", { class: textClassComputed.value }, [labelComputed.value])]
        ),
        h(
          "span",
          {
            class: "gt-dropdown-icon"
          },
          [h(_sfc_main$J, { name: "down" })]
        ),
        h(
          "div",
          {
            class: classShowComputed.value,
            onMouseleave: handleLeave,
            style: popupStyle.value
          },
          childs.value
        ),
        errorMsg.value ? h("span", {
          class: "dropdown-error-msg",
          innerHTML: errorMsg.value
        }) : []
      ]
    );
  }
};
_sfc_main$z.install = function(Vue) {
  Vue.component(_sfc_main$z.name, _sfc_main$z);
};
_sfc_main$A.install = function(Vue) {
  Vue.component(_sfc_main$A.name, _sfc_main$A);
};
const __default__$q = {
  name: "GFilterChips"
};
const _sfc_main$y = /* @__PURE__ */ Object.assign(__default__$q, {
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    label: {},
    index: {
      type: Number,
      default: null
    }
  },
  emits: ["update:modelValue", "update:clickIndex"],
  setup(__props, { emit }) {
    const props = __props;
    const { modelValue, label, index: index2 } = toRefs(props);
    const isActive = computed(() => {
      return modelValue.value === true;
    });
    const handleClick = () => {
      let result = modelValue.value === true ? false : true;
      emit("update:modelValue", result);
      emit("update:clickIndex", index2.value, result);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-filter-chips", unref(isActive) ? "active" : ""]),
        onClick: handleClick
      }, toDisplayString(unref(label)), 3);
    };
  }
});
_sfc_main$y.install = function(Vue) {
  Vue.component(_sfc_main$y.name, _sfc_main$y);
};
const __default__$p = {
  name: "GFilterChipsGroup"
};
const _sfc_main$x = /* @__PURE__ */ Object.assign(__default__$p, {
  props: {
    modelValue: {}
  },
  emits: ["update:modelValue", "update:modelValue"],
  setup(__props, { emit }) {
    const props = __props;
    const slots = ref(useSlots());
    const { modelValue } = toRefs(props);
    const chips = ref([]);
    const list = computed(() => {
      let result = findAllChips(slots.value.default()).map((child, idx) => {
        chips.value[idx] = idx === modelValue.value ? true : false;
        let result2 = {
          ...child,
          props: {
            ...child.props,
            index: idx,
            modelValue: chips.value[idx],
            "onUpdate:clickIndex": (idx2, result3) => {
              updateModelValue(idx2);
            }
          }
        };
        return result2;
      });
      return result;
    });
    const findAllChips = (slots2) => {
      var _a2;
      let result = [];
      for (let i = 0; i < slots2.length; i++) {
        if (((_a2 = slots2[i].children) == null ? void 0 : _a2.length) !== 0 && slots2[i].children instanceof Array) {
          result.push(...findAllChips(slots2[i].children));
        } else if (slots2[i].type instanceof Object && slots2[i].type.name === "GFilterChips") {
          result.push(slots2[i]);
        }
      }
      return result;
    };
    const updateModelValue = (idx, result) => {
      emit("update:modelValue", idx);
    };
    const render = computed(() => {
      return h("div", {}, list.value);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(render));
    };
  }
});
_sfc_main$x.install = function(Vue) {
  Vue.component(_sfc_main$x.name, _sfc_main$x);
};
const validFormTarget = ["GInput", "GRadiobox", "GCheckbox", "GDropdown"];
const _sfc_main$w = {
  name: "GForm",
  props: {
    name: {
      default: null
    },
    modelValue: {
      default: {}
    },
    rules: {
      type: Object,
      default: {}
    }
  },
  emits: ["update:modelValue"],
  setup(props, { slots, emit, expose }) {
    getCurrentInstance();
    const validResult = reactive({});
    const inputs = props.modelValue;
    const callValid = () => {
      return new Promise(async (resolv, reject) => {
        for (let fieldName in props.rules) {
          await handleRulesValid(inputs[fieldName], fieldName).then((res) => {
            validResult[fieldName] = null;
          }).catch((err) => {
            validResult[fieldName] = { message: err };
          });
        }
        resolv(validResult);
      });
    };
    expose({ callValid });
    const handleValChange = (val, name) => {
      inputs[name] = val;
      emit("update:modelValue", inputs);
    };
    const ruleValid = (value, { require = false, message = "", valid = null }) => {
      return new Promise((resolv, reject) => {
        if (require && !value) {
          reject(message);
        }
        if (valid && !valid(value)) {
          reject(message);
        }
        resolv(true);
      });
    };
    const handleRulesValid = async (value, name, triggerType = "submit") => {
      if (validResult[name]) {
        validResult[name] = null;
      }
      let rules = props.rules;
      return new Promise((resolve, reject) => {
        if (rules[name] && Array.isArray(rules[name])) {
          let arr = [];
          rules[name].forEach((itemObj) => {
            if (itemObj["trigger"] === triggerType || triggerType === "submit") {
              arr.push(ruleValid(value, itemObj));
            }
          });
          Promise.all(arr).then((res) => {
            validResult[name] = null;
            resolve(true);
          }).catch((err) => {
            validResult[name] = { message: err };
            reject(err);
          });
        } else {
          resolve(true);
        }
      });
    };
    const genNodeTree = (item) => {
      return {
        ...item,
        children: Array.isArray(item.children) ? item.children.map((cItem) => genNodeTree(cItem)) : item.children,
        props: validFormTarget.includes(item.type.name) ? {
          ...item.props,
          formParentValue: props.modelValue[item.props.name],
          validResult,
          handleValChange,
          handleRulesValid
        } : {
          ...item.props
        }
      };
    };
    const validChilds = slots.default() ? slots.default().map((item) => genNodeTree(item)) : [];
    return () => h("form", { class: "gt-form" }, validChilds);
  }
};
_sfc_main$w.install = function(Vue) {
  Vue.component("GForm", _sfc_main$w);
};
const _hoisted_1$o = { class: "gt-upload-icon" };
const _hoisted_2$k = /* @__PURE__ */ createElementVNode("div", { class: "inner" }, null, -1);
const _sfc_main$v = {
  __name: "GUploadIcon",
  props: {
    percent: {
      type: Number,
      default: 0
    },
    auto: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const { percent, auto } = __props;
    const percentNum = ref(percent);
    const styleComputed = computed(() => {
      return {
        background: `conic-gradient(#55585e 0 ${percentNum.value}%, #aaa 0 100%)`
      };
    });
    onMounted(() => {
      if (auto) {
        setInterval(() => {
          percentNum.value = percentNum.value + 10;
          if (percentNum.value > 100) {
            percentNum.value = 0;
          }
        }, 500);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$o, [
        createElementVNode("div", {
          class: "pie",
          style: normalizeStyle(unref(styleComputed))
        }, null, 4),
        _hoisted_2$k,
        createVNode(unref(_sfc_main$J), {
          name: "upload",
          class: "w-full svgbox"
        })
      ]);
    };
  }
};
const _sfc_main$u = {
  __name: "GButtonFile",
  props: {
    name: {
      type: String,
      default: "file"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$L), {
        round: "",
        noBorder: "",
        type: "black",
        class: "gt-button-file"
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$J), {
            name: __props.name,
            size: "md"
          }, null, 8, ["name"])
        ]),
        _: 1
      });
    };
  }
};
const _hoisted_1$n = ["data-active", "onDragenter", "onDragover", "onDragleave", "onDrop"];
const _sfc_main$t = {
  __name: "DropZone",
  emits: ["files-dropped"],
  setup(__props, { emit }) {
    let active = ref(false);
    let inActiveTimeout = null;
    function setActive() {
      active.value = true;
      clearTimeout(inActiveTimeout);
    }
    function setInactive() {
      inActiveTimeout = setTimeout(() => {
        active.value = false;
      }, 50);
    }
    function onDrop(e) {
      setInactive();
      emit("files-dropped", [...e.dataTransfer.files]);
    }
    function preventDefaults(e) {
      e.preventDefault();
    }
    const events = ["dragenter", "dragover", "dragleave", "drop"];
    onMounted(() => {
      events.forEach((eventName) => {
        document.body.addEventListener(eventName, preventDefaults);
      });
    });
    onUnmounted(() => {
      events.forEach((eventName) => {
        document.body.removeEventListener(eventName, preventDefaults);
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-active": unref(active),
        onDragenter: withModifiers(setActive, ["prevent"]),
        onDragover: withModifiers(setActive, ["prevent"]),
        onDragleave: withModifiers(setInactive, ["prevent"]),
        onDrop: withModifiers(onDrop, ["prevent"])
      }, [
        renderSlot(_ctx.$slots, "default", { dropZoneActive: unref(active) })
      ], 40, _hoisted_1$n);
    };
  }
};
const _hoisted_1$m = { class: "text" };
const _hoisted_2$j = { class: "imgLoaded" };
const _hoisted_3$g = ["src"];
const __default__$o = {
  name: "GImgUpload"
};
const _sfc_main$s = /* @__PURE__ */ Object.assign(__default__$o, {
  emits: ["file"],
  setup(__props, { emit }) {
    const fileInputForm = ref();
    const img = ref(null);
    const isLoading = ref(false);
    const imgLoaded = ref(false);
    const handleClick = () => {
      if (!imgLoaded.value && !img.value) {
        fileInputForm.value["imgInput"].click();
      }
    };
    const handleFile = (file) => {
      isLoading.value = true;
      let reader = new FileReader();
      reader.onload = (e) => {
        img.value = e.target.result;
        imgLoaded.value = true;
        isLoading.value = false;
        emit("file", file);
      };
      reader.readAsDataURL(file);
    };
    const handleDropFile = (files) => {
      if (!files.length || !files[0])
        return false;
      handleFile(files[0]);
    };
    const onFileChange = (evt) => {
      let files = evt.target.files || evt.dataTransfer.files;
      if (!files.length || !files[0])
        return false;
      handleFile(files[0]);
    };
    const handleRemove = () => {
      imgLoaded.value = false;
      img.value = null;
      fileInputForm.value.reset();
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$t, {
        class: "gt-img-upload-wrapper",
        onFilesDropped: handleDropFile
      }, {
        default: withCtx(({ dropZoneActive }) => [
          createElementVNode("div", {
            class: normalizeClass(["gt-img-upload", dropZoneActive ? "zone-active" : ""]),
            onDragover: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["prevent"])),
            onClick: handleClick
          }, [
            withDirectives(createElementVNode("div", _hoisted_1$m, "\u62D6\u66F3\u4E0A\u50B3\u9078\u64C7\u5716\u7247", 512), [
              [vShow, !isLoading.value && !imgLoaded.value]
            ]),
            isLoading.value ? (openBlock(), createBlock(_sfc_main$v, {
              key: 0,
              class: "mr-2",
              percent: 0,
              auto: ""
            })) : createCommentVNode("", true),
            imgLoaded.value ? (openBlock(), createBlock(_sfc_main$u, {
              key: 1,
              class: "deleteIcon",
              name: "trash",
              onClick: withModifiers(handleRemove, ["stop"])
            }, null, 8, ["onClick"])) : createCommentVNode("", true),
            createElementVNode("div", _hoisted_2$j, [
              withDirectives(createElementVNode("img", {
                src: img.value,
                alt: "img"
              }, null, 8, _hoisted_3$g), [
                [vShow, imgLoaded.value]
              ])
            ]),
            createElementVNode("form", {
              action: "",
              ref_key: "fileInputForm",
              ref: fileInputForm,
              class: "none"
            }, [
              createElementVNode("input", {
                name: "imgInput",
                type: "file",
                hidden: "",
                onChange: onFileChange
              }, null, 32)
            ], 512)
          ], 34)
        ]),
        _: 1
      });
    };
  }
});
_sfc_main$s.install = function(Vue) {
  Vue.component(_sfc_main$s.name, _sfc_main$s);
};
const _hoisted_1$l = { class: "gt-input-wrapper" };
const _hoisted_2$i = {
  key: 0,
  class: "gt-input-label"
};
const _hoisted_3$f = ["placeholder", "type", "disabled"];
const _hoisted_4$b = ["rows", "placeholder", "type", "disabled"];
const _hoisted_5$9 = {
  key: 4,
  class: "gt-input-error-msg"
};
const _hoisted_6$5 = ["onClick"];
const __default__$n = {
  name: "GInput"
};
const _sfc_main$r = /* @__PURE__ */ Object.assign(__default__$n, {
  props: {
    name: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: {},
    formParentValue: {},
    handleValChange: {},
    label: {
      type: String,
      default: null
    },
    width: {
      type: Number,
      default: null
    },
    type: {
      default: "text"
    },
    rows: {
      default: 3
    },
    inputStyle: {},
    clearable: {
      type: Boolean,
      default: false
    },
    theme: {
      type: String,
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    validResult: {
      default: {}
    },
    handleRulesValid: {
      type: Function
    },
    size: {
      type: String,
      default: "sm"
    },
    onInput: {
      type: Function
    },
    onBlur: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    onChange: {
      type: Function
    },
    iconClasses: {
      type: String
    },
    iconPosition: {
      type: String,
      default: "right"
    },
    searchSelectMode: {
      type: Boolean,
      default: false
    },
    selectOptions: {
      type: Array
    },
    selectedOptions: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  emits: [
    "update:modelValue",
    "input",
    "focus",
    "blur",
    "change"
  ],
  setup(__props, { expose, emit }) {
    const props = __props;
    const inputUuid = v4();
    const instance = getCurrentInstance();
    const TYPES = ["text", "number", "password", "tex-select", "textarea"];
    const placeholderDefaultMap = {
      text: "\u8F38\u5165\u6587\u5B57\u5167\u5BB9",
      number: "\u8F38\u5165\u6578\u5B57\u5167\u5BB9",
      password: "\u8F38\u5165\u5BC6\u78BC"
    };
    const value = ref(props.modelValue || props.formParentValue);
    watch(
      () => props.modelValue,
      () => {
        value.value = props.modelValue;
      }
    );
    const {
      name,
      disabled,
      label,
      width,
      type,
      theme,
      clearable,
      placeholder,
      formParentValue,
      validResult,
      handleRulesValid,
      size,
      iconClasses,
      iconPosition
    } = props;
    const rows = computed(() => props.rows);
    const inputStyle = ref(props.inputStyle);
    const isFocused = ref(false);
    const errorMsg = computed(() => {
      var _a2;
      return (_a2 = validResult[name]) == null ? void 0 : _a2.message;
    });
    const classComputed = computed(() => {
      var _a2;
      let classStr = [];
      if (theme) {
        classStr.push("gt-input-" + theme);
      }
      if ((_a2 = validResult[name]) == null ? void 0 : _a2.message) {
        classStr.push("gt-input-error");
      }
      if (size === "sm") {
        classStr.push("gt-input-sm");
      }
      if (iconClasses) {
        classStr.push(`icon-${iconPosition}`);
      }
      if (props.disabled) {
        classStr.push("disabled");
      }
      return classStr;
    });
    const closeSelectOptions = () => {
      isFocused.value = false;
    };
    watch(
      [
        () => {
          return isFocused;
        }
      ],
      (newValue) => {
        if (newValue) {
          document.body.addEventListener("click", closeSelectOptions);
        } else {
          document.body.removeEventListener("click", closeSelectOptions);
        }
      },
      { deep: true }
    );
    const selectModeClassComputed = computed(() => {
      let arr = [];
      arr.push(isFocused.value ? "tp-aniIn" : "tp-aniOut");
      return arr;
    });
    const selectModeStyleComputed = computed(() => {
      return {
        width: "100%",
        top: size === "sm" ? "40px" : "48px",
        left: "0px"
      };
    });
    const selectOptionsComputed = computed(() => {
      if (!props.modelValue)
        return props.selectOptions;
      return props.selectOptions.filter((item) => {
        return ("" + item.value).includes(props.modelValue);
      });
    });
    const handleClear = () => {
      handleInput(null, null);
      if (handleRulesValid) {
        handleRulesValid(value.value, name, "blur");
      }
    };
    const handleInput = (e, val) => {
      value.value = val != null ? val : e == null ? void 0 : e.target.value;
      if (props.handleValChange) {
        props.handleValChange(value.value, props.name);
      } else {
        emit("update:modelValue", value.value);
        emit("input", value.value);
      }
    };
    const handleChange = (e, val) => {
      let temp = val != null ? val : e.target.value;
      value.value = temp;
      emit("update:modelValue", temp);
      emit("change", temp);
    };
    const handleSelectedOption = (item) => {
      props.selectedOptions[0] = item;
      handleChange(null, item.label);
      closeSelectOptions();
    };
    const handleFocus = (e) => {
      isFocused.value = true;
      emit("focus", e);
    };
    const handleBlur = (e) => {
      if (handleRulesValid && name) {
        handleRulesValid(value.value, name, "blur");
      }
      emit("blur", e);
    };
    const focusInput = (e) => {
      if (instance.refs[inputUuid]) {
        instance.refs[inputUuid].focus(e);
      }
    };
    const blurInput = (e) => {
      if (instance.refs[inputUuid]) {
        instance.refs[inputUuid].blur(e);
      }
    };
    expose({
      focus: focusInput,
      blur: blurInput
    });
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        unref(label) ? (openBlock(), createElementBlock("div", _hoisted_2$i, toDisplayString(unref(label)), 1)) : createCommentVNode("", true),
        createElementVNode("div", {
          class: "gt-relative",
          style: { "flex-grow": "1" },
          onClick: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"]))
        }, [
          unref(type) !== "textarea" ? withDirectives((openBlock(), createElementBlock("input", {
            key: 0,
            ref: unref(inputUuid),
            class: normalizeClass([unref(classComputed), "gt-input"]),
            style: normalizeStyle(unref(width) ? { width: unref(width) + "px" } : {}),
            placeholder: unref(placeholder) || placeholderDefaultMap[unref(type)],
            type: TYPES.includes(unref(type)) ? unref(type) : "text",
            onInput: handleInput,
            onChange: handleChange,
            onFocus: handleFocus,
            onBlur: handleBlur,
            disabled: unref(disabled),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event)
          }, null, 46, _hoisted_3$f)), [
            [vModelDynamic, value.value]
          ]) : withDirectives((openBlock(), createElementBlock("textarea", {
            key: 1,
            ref: unref(inputUuid),
            class: normalizeClass([unref(classComputed), "gt-input"]),
            style: normalizeStyle(inputStyle.value),
            rows: unref(rows),
            placeholder: unref(placeholder) || placeholderDefaultMap[unref(type)],
            type: TYPES.includes(unref(type)) ? unref(type) : "text",
            onInput: handleInput,
            onChange: handleChange,
            onFocus: handleFocus,
            onBlur: handleBlur,
            disabled: unref(disabled),
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => value.value = $event)
          }, null, 46, _hoisted_4$b)), [
            [vModelText, value.value]
          ]),
          unref(clearable) && !unref(iconClasses) ? (openBlock(), createBlock(_component_g_icon, {
            key: 2,
            onClick: withModifiers(handleClear, ["stop"]),
            class: "clear-icon",
            classes: "far fa-times-circle"
          }, null, 8, ["onClick"])) : createCommentVNode("", true),
          unref(iconClasses) ? (openBlock(), createBlock(_component_g_icon, {
            key: 3,
            class: normalizeClass(`gt-input-icon-${unref(iconPosition)}`),
            classes: unref(iconClasses)
          }, null, 8, ["class", "classes"])) : createCommentVNode("", true),
          unref(errorMsg) ? (openBlock(), createElementBlock("div", _hoisted_5$9, toDisplayString(unref(errorMsg)), 1)) : createCommentVNode("", true),
          props.searchSelectMode ? (openBlock(), createElementBlock("div", {
            key: 5,
            class: normalizeClass(["gt-input-select-mode", unref(selectModeClassComputed)]),
            style: normalizeStyle(unref(selectModeStyleComputed))
          }, [
            !props.selectOptions || props.selectOptions.length == 0 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(" \u7121\u9078\u9805 ")
            ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(selectOptionsComputed), (item, idx) => {
              return openBlock(), createElementBlock("div", {
                class: "gt-input-select-option",
                key: idx,
                onClick: () => {
                  handleSelectedOption(item);
                }
              }, toDisplayString(item.label), 9, _hoisted_6$5);
            }), 128))
          ], 6)) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
_sfc_main$r.install = function(Vue) {
  Vue.component(_sfc_main$r.name, _sfc_main$r);
};
const _hoisted_1$k = { class: "gt-input-number" };
const _hoisted_2$h = { class: "number" };
const __default__$m = {
  name: "GInputNumber"
};
const _sfc_main$q = /* @__PURE__ */ Object.assign(__default__$m, {
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: null
    },
    min: {
      type: Number,
      default: 0
    },
    unit: {
      type: Number,
      default: 1
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const props = __props;
    const minusClass = computed(() => {
      if (props.min) {
        return props.modelValue <= props.min ? "disabled" : "";
      }
      return props.modelValue < 1 ? "disabled" : "";
    });
    const plusClass = computed(() => {
      if (props.max) {
        return props.modelValue >= props.max ? "disabled" : "";
      }
      return "";
    });
    const handleNumber = (type) => {
      let val = props.modelValue;
      switch (type) {
        case "minus": {
          console.log(minusClass.value);
          if (minusClass.value !== "disabled") {
            emit("update:modelValue", val - props.unit);
          }
          break;
        }
        case "plus": {
          if (plusClass.value !== "disabled") {
            emit("update:modelValue", val + props.unit);
          }
          break;
        }
      }
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createElementVNode("div", {
          class: normalizeClass(["btn minus", unref(minusClass)]),
          onClick: _cache[0] || (_cache[0] = () => {
            handleNumber("minus");
          })
        }, [
          createVNode(_component_g_icon, { classes: "fas fa-minus" })
        ], 2),
        createElementVNode("div", _hoisted_2$h, toDisplayString(__props.modelValue), 1),
        createElementVNode("div", {
          class: normalizeClass(["btn plus", unref(plusClass)]),
          onClick: _cache[1] || (_cache[1] = () => {
            handleNumber("plus");
          })
        }, [
          createVNode(_component_g_icon, { classes: "fas fa-plus" })
        ], 2)
      ]);
    };
  }
});
_sfc_main$q.install = function(Vue) {
  Vue.component(_sfc_main$q.name, _sfc_main$q);
};
var _imports_0 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjkiIGhlaWdodD0iMjkiIHZpZXdCb3g9IjAgMCAyOSAyOSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOS4xOTg0NyAxMi41Mzc0TDEzLjAwMjEgMTIuNTI2M0wxMi45OTIgOS4yMDI4MUwxNS41NDg4IDkuMTk3NzVMMTUuNTU4OSAxMi41MTgyTDE5LjQxMzQgMTIuNTA3MUwxOS40MTg1IDE1LjA0ODJMMTUuNTY2IDE1LjA1OTNMMTUuNTc3MiAxOC41NDI1TDE5LjQ2NTMgMjIuNzg1OEgxNS44NDE3TDE0LjI4NTYgMjEuMDg4NkwxMi43MzA2IDIyLjc4NThIOS4xMDY5M0wxMy4wMjA0IDE4LjUxNTJMMTMuMDEwMyAxNS4wNjc0TDkuMjAzNTUgMTUuMDc4NUw5LjE5ODQ3IDEyLjUzNzRaIiBmaWxsPSIjMzJBMDNEIi8+DQo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIxLjA4NDEgMTcuNDk1N0MyMC4yODU3IDE4LjIyMDQgMTkuMjIzOSAxOC42NjQyIDE4LjA2MTUgMTguNjY0MkMxNy41MTc0IDE4LjY2NDIgMTYuOTk1NiAxOC41NjcxIDE2LjUxMjUgMTguMzg5MlYxNi4wMzMxSDIwLjM1OTlWMTEuNjA0OEgxNi41MTI1VjguMjYwMTRIMTIuMDU3VjExLjYwNDhIOC4yNjA0VjE2LjAzMzFIMTIuMDU3VjE4LjQ1MDlDMTEuNTk3MyAxOC42MDk2IDExLjEwMyAxOC42OTY1IDEwLjU5MDQgMTguNjk2NUM5LjM4NzI3IDE4LjY5NjUgOC4yOTI5NSAxOC4yMjE0IDcuNDg1NDMgMTcuNDUxMkM2LjgzMDQ3IDE3LjgyNDIgNi4wNzE3NyAxOC4wMzg1IDUuMjY1MjcgMTguMDM4NUMyLjc5Mjg4IDE4LjAzODUgMC43NzYxMjMgMTYuMDM0MSAwLjc3NjEyMyAxMy41NzY5QzAuNzc2MTIzIDExLjYwMjggMi4wNzc5MSA5LjkxOTg1IDMuODcxOTQgOS4zMzU2MkMzLjgwOTkxIDkuMDQwNDcgMy43NzczNiA4LjczNjIyIDMuNzc3MzYgOC40MjI4OEMzLjc3NzM2IDUuOTY1NjYgNS43OTQxMiAzLjk2MTI3IDguMjY2NTEgMy45NjEyN0M4LjgyMDc4IDMuOTYxMjcgOS4zNTE2NyA0LjA2MTM0IDkuODQxODcgNC4yNDUzQzkuOTU2OCAxLjg4ODE1IDExLjkyNTggMCAxNC4zMjU5IDBDMTYuNjk2NiAwIDE4LjY0OTMgMS44NDM2NyAxOC44MDQ5IDQuMTYyNDJDMTkuMjIxOSA0LjAzNDA1IDE5LjY2NTMgMy45NjUzMSAyMC4xMjQgMy45NjUzMUMyMi41OTY0IDMuOTY1MzEgMjQuNjEzMSA1Ljk2OTcgMjQuNjEzMSA4LjQyNjkyQzI0LjYxMzEgOC43MzUyMSAyNC41ODE2IDkuMDM1NDIgMjQuNTIxNiA5LjMyNjUyQzI2LjQxMDIgOS44NTMxNCAyNy44MDE1IDExLjU4MjYgMjcuODAxNSAxMy42MjQ0QzI3LjgwMTUgMTYuMDgxNiAyNS43ODQ3IDE4LjA4NiAyMy4zMTI0IDE4LjA4NkMyMi41MDE4IDE4LjA4NiAyMS43NCAxNy44NzA3IDIxLjA4NDEgMTcuNDk1N1oiIGZpbGw9IiMzMkEwM0QiLz4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQ1NSAyMy43NzY5QzIxLjIwMzkgMjMuNzc2OSAyNi43Mjc0IDI2LjUwNiAyOC41Nzg0IDI4LjA5MTlDMjIuMDI4NyAyNC43MTc5IDcuMDY1MjcgMjQuNjMgMCAyOC4wOTE5QzIuNTQzNTggMjYuNDU4NSA3LjI4Njk4IDIzLjc3NjkgMTQuMjQ1NSAyMy43NzY5WiIgZmlsbD0iIzMyQTAzRCIvPg0KPC9zdmc+DQo=";
var _imports_1 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODEiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCA4MSAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik01Ni40NDY0IDcuNTczNDVMNTYuODk4OSA4LjA3Mzk0QzU3LjE5MjEgNy41OTgxNyA1Ny40ODg3IDcuMTU0NjYgNTcuNzQxNiA2LjY4ODVDNTcuODY5NCA2LjQ1MzAyIDU3Ljk4MjIgNi4zOTI2IDU4LjIyODkgNi41MDY1N0M1OC43NjYxIDYuNzUzNzIgNTkuMzE1NiA2Ljk3NjE2IDU5Ljg5MzIgNy4yMjMzMkM1OS44MTg3IDcuMzAzNjQgNTkuNzg1OCA3LjM3MTYxIDU5Ljc0MjggNy4zNzk4NUM1OS4yOTkyIDcuNDY0OTggNTkuMTI3NyA3Ljg0MDUyIDU4Ljg5MDUgOC4xNTM1OEM1OC41NzQgOC41NzQ0MyA1OC4yNDQ2IDguOTg0MjkgNTcuODU2NCA5LjQ4MTM1TDU5LjEzNjUgOC45MTQ5NUM1OS4yNzMyIDkuMTg0NzYgNTkuNDI3IDkuNDQyMjEgNTkuNTI4OSA5LjcxOTU4QzU5Ljc3NDkgMTAuMzkwMyA2MC4wMDExIDExLjA2ODYgNjAuMjE3MSAxMS43NDk3QzYwLjI0NjUgMTEuODQyNCA2MC4yMDM0IDEyLjAzNjYgNjAuMTM3MiAxMi4wNjk2QzU5LjcxMiAxMi4yODE3IDU5LjI3MTIgMTIuNDYyMyA1OC43OTgyIDEyLjY2OTZDNTguNzM5NSAxMi40MzA3IDU4LjY5MDkgMTIuMjMwOSA1OC42MzA4IDExLjk4ODZDNTcuOTc5NCAxMi4wNTcyIDU3LjMzMjIgMTIuMTI1OSA1Ni42ODYzIDEyLjE4OTFDNTYuNDY1NSAxMi4yMTE3IDU2LjI0MDcgMTIuMjEzMSA1Ni4wMjQgMTIuMjU3N0M1NS42MzAzIDEyLjMzMTkgNTUuMTc0NSAxMi4yMTE3IDU0Ljg3OTIgMTIuNzA3NEM1NC42NjUzIDEyLjE1ODIgNTQuNDg0MiAxMS42OTc1IDU0LjMwMzcgMTEuMjM1NUw1NC4yMzU0IDExLjI0OTlWMTEuOTY1M0M1My44MjA1IDExLjk2NTMgNTMuNDM2NCAxMS45NTk4IDUzLjA1MyAxMS45NjUzQzUyLjc3NDEgMTEuOTcwMSA1Mi4zMTc1IDEyLjM3NzIgNTIuMzA1MiAxMi42MDAzQzUyLjI5MjkgMTIuODIzNCA1Mi4zNzM2IDEyLjkyOTggNTIuNjA3MyAxMi45MDQ0QzUyLjcyNDEgMTIuODk4MyA1Mi44NDEyIDEyLjg5ODMgNTIuOTU4IDEyLjkwNDRDNTUuMTMzNCAxMi45MDQ0IDU3LjMwODkgMTIuOTA5OSA1OS40ODQ0IDEyLjg5NzZDNTkuODAxNiAxMi44OTc2IDU5Ljg2MTcgMTMuMDA5NSA1OS44MjYyIDEzLjI5MTZDNTkuNjk0OSAxNC4yNzQ4IDU4Ljk1MDYgMTQuODgzNyA1Ny43NjgyIDE0LjkxMjZDNTYuNzk3NyAxNC45MzY2IDU1LjgyNjUgMTQuOTIwOCA1NC44NTYgMTQuOTIyMkg1NC4zNDM0QzU2LjE1NzMgMTYuMzA4MyA1OC4xMzUzIDE3LjA2NDIgNjAuMzM3NCAxNy40NzQxQzU5Ljk3MzEgMTcuOTczMiA1OS41NjAzIDE4LjI3MjUgNTkuMDUyNSAxOC40MzUyQzU3Ljc1MzkgMTguODU2NyA1Ni41MzU5IDE4LjU4MzUgNTUuMzU2OSAxOC4wMDJDNTQuMzYxOCAxNy41MTExIDUzLjUwNDcgMTYuODIxOCA1Mi42NzkxIDE2LjA4ODZDNTIuNTg1NSAxNi4wMDU1IDUyLjQ4NzcgMTUuOTI2NiA1Mi4zMzc0IDE1Ljc5NzVDNTIuMzI1NyAxNS45ODYzIDUyLjMxMjggMTYuMTA3OCA1Mi4zMTI4IDE2LjIyOTRDNTIuMzEyOCAxNy4wNzU5IDUyLjMwMzkgMTcuOTIxNyA1Mi4zMTc1IDE4Ljc2OTZDNTIuMzIxNiAxOS4wNDkgNTIuMjE5MSAxOS4xNDEgNTEuOTQ5MSAxOS4xMzQxQzUxLjM4OCAxOS4xMjA0IDUwLjgyNjIgMTkuMTE3NiA1MC4yNjUxIDE5LjEzNDFDNDkuOTgyMSAxOS4xNDIzIDQ5LjkwNzYgMTkuMDMxOCA0OS45MTE3IDE4Ljc2MTNDNDkuOTI2MSAxNy45MDM4IDQ5LjkxNzIgMTcuMDQ1IDQ5LjkxNzIgMTYuMTg4MlYxNS42OTczQzQ5LjUyNDkgMTYuMDQ2IDQ5LjE4OTMgMTYuMzQ5NSA0OC44NDgyIDE2LjY0NTRDNDcuODAwNSAxNy41NTM3IDQ2LjY3MTQgMTguMzE5OSA0NS4yNjYyIDE4LjUzMkM0NC4yMDY4IDE4LjY5MiA0My4xODkxIDE4LjU2NyA0Mi4yODk2IDE3LjkxNDFDNDIuMTgyMyAxNy44MzU5IDQyLjA5MTQgMTcuNzM0MyA0MS45MjI2IDE3LjU3ODRDNDQuMDg5OSAxNy4yMjA3IDQ1Ljk0OTYgMTYuMzkxNCA0Ny42MzE3IDE0LjkzMTFINDIuNDM1OUM0Mi40MzU5IDE0LjI3NTUgNDIuNDI5MSAxMy42Njc5IDQyLjQ0NjggMTMuMDYxN0M0Mi40NDY4IDEzLjAwNTQgNDIuNjA3NCAxMi45MTI3IDQyLjY5NyAxMi45MDc5QzQzLjAzNTMgMTIuODg5MyA0My4zNzUgMTIuODk5NiA0My43MTQgMTIuODk5Nkg0OS41MDM3SDQ5Ljg4MVYxMS45ODA0QzQ5LjM2NDkgMTEuOTgwNCA0OC43NTA1IDExLjgwNzMgNDguMzUgMTIuMDI3N0M0Ny45Mjc2IDEyLjI1OTEgNDcuNDc5OSAxMi4zNTA0IDQ3LjA2MTYgMTIuNTQ0QzQ2Ljk3NyAxMi41NzI2IDQ2Ljg4OTQgMTIuNTkxMiA0Ni44MDA2IDEyLjU5OTZDNDYuNTkxNCAxMS45NzYyIDQ2LjU5NTUgMTEuOTg1OCA0NS45MzM5IDEyLjA2NjlDNDUuMjUwNCAxMi4xNTA2IDQ0LjU2MTUgMTIuMTk4NyA0My44Nzg3IDEyLjI5MDdDNDMuNTU2MSAxMi4zMzQ2IDQzLjI0MTcgMTIuNDQ1OCA0Mi44NTM1IDEyLjU0NDdDNDIuNjc5OSAxMS45ODc5IDQyLjQ4MTcgMTEuMzUyOSA0Mi4yNzM5IDEwLjY4NTVDNDIuNDI4NCAxMC42NjkxIDQyLjUxMTEgMTAuNjQwOSA0Mi41ODU2IDEwLjY1NTNDNDMuMTcwNiAxMC43NzE0IDQzLjUyNDcgMTAuNDc2MSA0My43OTQgMTAuMDAwNEM0My45MDI2IDkuODA4ODMgNDQuMDQxNCA5LjYzNDQ1IDQ0LjE5OTkgOS40MDMwOEM0My42MzMzIDguNzkxMzcgNDMuMDg3MiA4LjE4MTczIDQyLjUxNTIgNy41OTc0OEM0Mi4zMzM0IDcuNDEwNzQgNDIuMjg2MiA3LjI4OTIyIDQyLjQ2MTkgNy4wNzIyOEM0Mi43MTA3IDYuNzYzMzMgNDIuOTIzOSA2LjQyNjI0IDQzLjE3MDYgNi4wNzU0Mkw0My42MTM1IDYuNDAyOUM0My45MDY3IDUuNzc2NzggNDQuMjEyMiA1LjE3MTkzIDQ0LjQ3MTMgNC41NDkyNEM0NC41ODM0IDQuMjc5NDMgNDQuNjkwNyA0LjI1MTI4IDQ0LjkzNjcgNC4zNjY2MkM0NS40NDkzIDQuNjA2OTEgNDUuOTc1NiA0LjgxODM2IDQ2LjUyMzEgNS4wNTMxNkM0Ni40NjIyIDUuMTMwNzQgNDYuNDM4MyA1LjE5MDQ3IDQ2LjQwNjIgNS4xOTY2NUM0NS45ODA0IDUuMjYxODcgNDUuODczMSA1LjYzNjAzIDQ1LjY4NTEgNS45MzMzMUM0NS4zNTk4IDYuNDQ2ODQgNDUuMDMxIDYuOTU5IDQ0LjY5MzQgNy40ODgzMkw0NS4xMjQgNy45OTYzNkw0Ni4wMjk2IDYuNDEzMkw0Ny44ODkzIDcuMjAzNDFDNDcuODUxIDcuMjc4MjQgNDcuODM5NCA3LjMzMTEgNDcuODIxIDcuMzM0NTRDNDcuMzczMyA3LjQwOCA0Ny4yMDU5IDcuNzgwNzkgNDYuOTgwMyA4LjEwMjc3QzQ2LjQyNTMgOC44OTg0OCA0NS44NTg3IDkuNjgxODIgNDUuMjgzMiAxMC40OTYxSDQ2LjI3MDlDNDYuMTY0MiAxMC4xOTYgNDYuMDcyNyA5LjkzNTE1IDQ1Ljk1OTkgOS42MTY2QzQ2LjQwNDEgOS40NzkyOSA0Ni44MzEzIDkuMzQxOTggNDcuMjY1MyA5LjIzMzUxQzQ3LjMxNjYgOS4yMjA0NiA0Ny40MzYyIDkuMzM3ODYgNDcuNDcwNCA5LjQxNzVDNDcuNjMzIDkuODAzMzQgNDcuNzc3OSAxMC4xOTc0IDQ3Ljk1OSAxMC42NjQ5QzQ3Ljk1OSA5LjYyMjA5IDQ3Ljk1OSA4LjY1NTQ0IDQ3Ljk1OSA3LjY4ODFDNDcuOTU5IDcuMDY2MSA0Ny45NjcyIDYuNDQyNzIgNDcuOTU5IDUuODIwNzFDNDcuOTU0MyA1LjU3NDI1IDQ4LjA0NTggNS40ODkxMiA0OC4yODY0IDUuNDk4MDRDNDguNjcxOSA1LjUxMjQ2IDQ5LjA1ODcgNS41MDkwMiA0OS40NDQyIDUuNDk4MDRDNDkuNTMzMSA1LjQ5ODA0IDQ5LjY3NDYgNS40NDU4NiA0OS42OTg1IDUuMzgyN0M0OS44NDY4IDQuOTgxMDggNDkuOTcxOSA0LjU2OTg0IDUwLjExNCA0LjEyMTUzQzQ5LjcyMzggNC4xMjE1MyA0OS4zOTg0IDQuMTE1MzUgNDkuMDczOCA0LjEyNjMzQzQ5LjAzNDQgNC4xMjg2NyA0OC45OTU5IDQuMTM5MDggNDguOTYwNiA0LjE1NjlDNDguOTI1MyA0LjE3NDczIDQ4Ljg5NDEgNC4xOTk2IDQ4Ljg2ODcgNC4yM0M0OC41MTg4IDQuNzI1NjggNDcuOTkxOCA0Ljg3MjYgNDcuNDQxIDQuOTU0OTlDNDcuMTY3NiA0Ljk5NjE4IDQ2LjgwMjYgNS4wODg4NiA0Ni42MzM4IDQuOTU0OTlDNDYuNDgwNyA0LjgzNDg0IDQ2LjUzNzQgNC40NDM1MSA0Ni40OTcxIDQuMTMxMTRDNDYuMzg3NyA0LjEyNDk2IDQ2LjI2NCA0LjExMTkxIDQ2LjEzOTYgNC4xMTEyM0M0NS4wMTc0IDQuMTExMjMgNDMuODk0NCA0LjEwMDkzIDQyLjc3MTUgNC4xMTUzNUM0Mi40NzgzIDQuMTE5NDcgNDIuMzgxMiA0LjAyNTQxIDQyLjM5NTYgMy43MzQzMkM0Mi40MTgxIDMuMzExOTQgNDIuNDE4MSAyLjg4ODY1IDQyLjM5NTYgMi40NjYyOEM0Mi4zNzcxIDIuMTUwNDcgNDIuNDYzOSAyLjAzODU2IDQyLjc5ODggMi4wNDU0M0M0My44OTc4IDIuMDY3NCA0NC45OTc2IDIuMDUzNjcgNDYuMDk2NiAyLjA1MzY3SDQ2LjU0MDFDNDYuNTQwMSAxLjY4NTY4IDQ2LjU0MDEgMS4zMzg5OCA0Ni41NDAxIDAuOTkxNTg4QzQ2LjU0MDEgMC44MzI5OTcgNDYuNTYyIDAuNzA5NDIxIDQ2Ljc2NDMgMC43MjA0MDZDNDcuNjI2OSAwLjc2OTE1IDQ4LjQ4ODcgMC44MTQ0NjEgNDkuNDI5OSAwLjg2NTI2NUM0OS4zNDM4IDEuMDAyNTcgNDkuMzA4MiAxLjExMjQyIDQ5LjIzMyAxLjE3MTQ2QzQ4Ljg2NCAxLjQ2MjU2IDQ4Ljg1MyAxLjQ3OTcyIDQ4Ljk1OTYgMi4wMjgyNkg1My4yODgxQzUzLjI4ODEgMS42NjUwOCA1My4yOTI5IDEuMzE2MzIgNTMuMjg4MSAwLjk2NzU2MUM1My4yODgxIDAuNzg5MDYgNTMuMzQ4MiAwLjcxMDc5NCA1My41MzQ4IDAuNzIxNzc4QzU0LjM3NDggMC43NzA1MjMgNTUuMjE1NSAwLjgxMTcxNSA1Ni4wNTU1IDAuODU5MDg2QzU2LjA4NTUgMC44NTkwODYgNTYuMTE0MiAwLjg4OTI5NSA1Ni4yMjU2IDAuOTQ5NzFDNTYuMDg4OSAxLjA2NzggNTUuOTk4IDEuMTk3NTUgNTUuODczIDEuMjUxMUM1NS41Mzg3IDEuMzk0NTkgNTUuNjkyNSAxLjY2ODUyIDU1LjcwMjggMS44ODQwOUM1NS43MDYyIDEuOTQ1ODggNTUuOTIzNSAyLjA0NDc0IDU2LjA0NDUgMi4wNDYxMkM1Ny4yMTQ2IDIuMDU4NDcgNTguMzg0IDIuMDYzMjggNTkuNTUzNSAyLjA0NjEyQzU5Ljg2MTcgMi4wNDEzMSA1OS45MzA3IDIuMTUxODQgNTkuOTEzIDIuNDM2MDdDNTkuODQ5NCAzLjQ2MDM5IDU5LjM5OSAzLjk4NjI4IDU4LjM4ODggNC4wNjM4NkM1Ny41OTgxIDQuMTI0OTYgNTYuODAwNCA0LjEwNTc0IDU2LjAwNTYgNC4xMTEyM0M1NS45MTU0IDQuMTA2NCA1NS44MjU0IDQuMTIyNDcgNTUuNzQyNCA0LjE1ODE5QzU1LjY1OTUgNC4xOTM5IDU1LjU4NTggNC4yNDgzIDU1LjUyNzEgNC4zMTcxOUM1NS4zMjIxIDQuNTI3OTYgNTUuMDQxOSA0LjY2OTM5IDU0Ljc3NTMgNC44MTM1NkM1NC42MzcxIDQuODc3NzggNTQuNDg4NCA0LjkxNjM5IDU0LjMzNjUgNC45Mjc1M0M1NC4wMzU4IDQuOTY1OTcgNTMuNjcyMiA1LjA5ODQ3IDUzLjQ0OCA0Ljk3ODMzQzUzLjI3ODUgNC44ODYzMyA1My4yODUzIDQuNDY0OCA1My4yMDEzIDQuMTQzNUg1MS4xNDY4TDUyLjYyOTkgNC41NDQ0M0w1Mi42NjY4IDQuNjM3ODFDNTIuMjYyMiA0Ljc3NTExIDUxLjk2MjEgNS4wMDUxIDUxLjkwNDcgNS40Nzg4Mkg1NC4yMzRWNi45OTc0NEw1NC44MzY4IDYuMjA4NjFMNTUuMjk0MSA2LjUyMDk4QzU1LjY0OTUgNS43OTgwNiA1NS45OTY3IDUuMDkxNjEgNTYuMzU3NSA0LjM1NjMyTDU4LjI1NTUgNS4xOTMyMkM1OC4yMzY0IDUuMjY4NzQgNTguMjM0NCA1LjMwNzg3IDU4LjIyNTUgNS4zMDkyNEM1Ny43NDcxIDUuNDAxMjQgNTcuNjAzNSA1LjgyMjA5IDU3LjM4MDcgNi4xNzAxNkM1Ny4wODQ4IDYuNjM0OTUgNTYuNzcxNyA3LjA4ODA3IDU2LjQ0NjQgNy41NzM0NVpNNTQuMjczIDEwLjY3NDZDNTQuNTM3NSAxMC42MzY4IDU0LjgxOTcgMTAuNjgwNyA1NC45NTAzIDEwLjU2MDZDNTUuMjkyIDEwLjI1MTYgNTUuNTYxMyA5Ljg3NDA1IDU1Ljg0OSA5LjUzMDc4TDU0LjI3MyA3LjkyNDI3VjEwLjY3NDZaTTUwLjAxNjMgOS41MDI2M1YxMC4zMTQxSDUyLjEzNTFWOS41MDI2M0g1MC4wMTYzWk01Mi4xMjE0IDcuOTU2NTRWNy4xNzE4M0g1MC4wMjI0VjcuOTU2NTRINTIuMTIxNFpNNTcuNzU4NyA5LjU4NzA4QzU3LjQ4NTMgOS45MTczIDU3LjI2NjYgMTAuMTg1NyA1Ni45ODI5IDEwLjUzMDRMNTguMTI5MSAxMC40Mzk4TDU3Ljc1ODcgOS41ODcwOFoiIGZpbGw9IiMzMkEwM0QiLz4NCjxwYXRoIGQ9Ik02Ny4wNjc5IDguMzU3NTJIODAuNDMyNkM4MC40MzI2IDguNzg0MjggODAuNDQ4NiA5LjE4MjE3IDgwLjQzMjYgOS41NzUyNkM4MC4zNTAxIDExLjI4ODUgODAuMjk0IDEzLjAwNDQgODAuMTU1MyAxNC43MTI4QzgwLjA3NDkgMTUuNjkwNyA3OS44ODc4IDE2LjY2NTIgNzkuNjcwMSAxNy42MjQ1Qzc5LjUwMjQgMTguMzc2MyA3OC45NTU0IDE4Ljg3MzkgNzguMTkyOSAxOC45NzgzQzc3LjMxNzQgMTkuMDk3OSA3Ni40MjUzIDE5LjEwMjcgNzUuNTM5NCAxOS4xMzQzQzc1LjQ1OTcgMTkuMTM0MyA3NS4zMzE0IDE4Ljk4MzEgNzUuMjk4OCAxOC44OEM3NS4xNjAyIDE4LjQyMDMgNzUuMDU1NSAxNy45NTE2IDc0LjkzODQgMTcuNDg1N0M3NC44ODg1IDE3LjI4NTcgNzQuNzcwNiAxNy4yMTA4IDc0LjU1NDMgMTcuMjEwOEM3My4xNzkxIDE3LjIxOTggNzEuODAzMSAxNy4yMTA4IDcwLjQyNzEgMTcuMjIyNUM3MC4zMTQ4IDE3LjIyMjUgNzAuMTM4NyAxNy4zMDUgNzAuMTAyNyAxNy4zOTM2QzY5Ljg3NzQgMTcuOTQzNCA2OS40NDM0IDE4LjIwMjUgNjguODg2OCAxOC4zMDI4QzY4LjU3NDIgMTguMzU5MSA2OC4yNTg4IDE4LjM5NjMgNjcuODk2OSAxOC40NDkyVjExLjYyOTNDNjguMDM1NiAxMS42MjMxIDY4LjE2MDQgMTEuNjEyOCA2OC4yODcyIDExLjYxMjhDNzAuNjcxOCAxMS42MTI4IDczLjA1NTcgMTEuNjE3NiA3NS40Mzk2IDExLjYwNTNDNzUuNzc2NCAxMS42MDUzIDc1Ljg4OTQgMTEuNjkzOSA3NS44ODUzIDEyLjAzNzVDNzUuODY3MyAxMy41MzA4IDc1Ljg4NTMgMTUuMDI0MSA3NS44Njg2IDE2LjUxNzRDNzUuODY0NSAxNi44NDggNzUuOTcyNiAxNi45Mjk4IDc2LjI5MTUgMTYuOTI5OEM3Ny4xMzIzIDE2LjkyMzYgNzcuMzYzOSAxNi44MDQgNzcuNDg4NiAxNS45Njc3Qzc3LjY1NjQgMTQuODQyNyA3Ny43NTU1IDEzLjcwNjcgNzcuODM5NCAxMi41NzE1Qzc3Ljg4NzkgMTEuOTA4MyA3Ny44NDc3IDExLjIzOSA3Ny44NDc3IDEwLjU0NzdINjYuODcxN0M2Ni43OTY4IDExLjEyNjMgNjYuNzUzMiAxMS43MTExIDY2LjY0MDIgMTIuMjgyMkM2Ni4zODc5IDEzLjU1ODMgNjYuMTY3NCAxNC44NDYxIDY1LjgwODMgMTYuMDk0OEM2NS4zODQxIDE3LjU3NjQgNjMuOTIyOSAxOC41OSA2Mi40NDUgMTguNTc0OUM2Mi4zMjA5IDE4LjU3NDkgNjIuMTk2MSAxOC41NTQzIDYyLjAyNDkgMTguNTM5MkM2Mi4yNDk1IDE4LjEzNDQgNjIuNDU5NSAxNy43ODMzIDYyLjY0MjUgMTcuNDIzOUM2My40NzQ0IDE1Ljc3NDYgNjMuODkwMyAxNC4wMDcxIDY0LjE4MjEgMTIuMjA1MkM2NC41NzQ1IDkuNzk1ODUgNjQuNjU0MiA3LjM2NzI2IDY0LjYyNDQgNC45MzE3OUM2NC42MTE5IDMuODYxODEgNjQuNjI0NCAyLjc5MTgzIDY0LjYxODggMS43MjE4NEM2NC42MTg4IDEuNDgzMzggNjQuNjg4MiAxLjM5MzM2IDY0Ljk0MzkgMS4zOTQwNUM2OS44NTQ1IDEuNDAwNDYgNzQuNzY1MSAxLjQwMDQ2IDc5LjY3NTcgMS4zOTQwNUM3OS45MDU4IDEuMzk0MDUgNzkuOTk0NSAxLjQ2Mjc3IDc5Ljk5MzggMS42OTM2N0M3OS45ODk3IDMuNDIyNjggNzkuOTg5NyA1LjE1MTQ3IDc5Ljk5MzggNi44ODAwM0M3OS45OTM4IDcuMTA4ODcgNzkuOTAwOSA3LjIwMzAxIDc5LjY3NzcgNy4xOTA2NEM3OS42MDg0IDcuMTg2NTIgNzkuNTM1NiA3LjE5MDY0IDc5LjQ2NDIgNy4xOTA2NEM3NS40NjczIDcuMTkwNjQgNzEuNDY5OSA3LjE4ODEyIDY3LjQ3MiA3LjE4MzA4QzY3LjE3MjYgNy4xODMwOCA2Ny4wMjg0IDcuMjQ1NjIgNjcuMDYwMyA3LjU3MDY3QzY3LjA4NzMgNy44MTE4OCA2Ny4wNjc5IDguMDYyMDIgNjcuMDY3OSA4LjM1NzUyWk02Ny4wNzkgMy40NzI4NUM2Ny4wNzkgMy45MjI5NyA2Ny4wOTU2IDQuMzMyNTUgNjcuMDczNCA0Ljc0MDA2QzY3LjA1ODIgNS4wMjY2MyA2Ny4xNDI3IDUuMTI0OSA2Ny40NDY0IDUuMTI0MjFDNzAuNTk5NyA1LjExNDU5IDczLjc1NDQgNS4xMTk0IDc2LjkwNyA1LjEyMDA5SDc3LjQ5ODNDNzcuNDk4MyA0LjY3MjcyIDc3LjQ3NzUgNC4yNzQxMyA3Ny41MDQ2IDMuODc4OTlDNzcuNTI3NSAzLjU1NiA3Ny40MjYyIDMuNDYzMjMgNzcuMDk0MiAzLjQ2NjY3QzczLjk2NDQgMy40Nzk3MiA3MC44MzQ3IDMuNDc0OTEgNjcuNzA0MiAzLjQ3NDkxTDY3LjA3OSAzLjQ3Mjg1Wk03My41NjM4IDE1LjIyNDFDNzMuNTYzOCAxNC43MDk0IDczLjU3MjggMTQuMjE4NyA3My41NTI3IDEzLjcyOTRDNzMuNTUyNyAxMy42NzAzIDczLjM5NTMgMTMuNTY4NiA3My4zMTAxIDEzLjU2NzJDNzIuMzM5NiAxMy41NTYyIDcxLjM2OTEgMTMuNTU2MiA3MC4zOTg3IDEzLjU2NzJDNzAuMzE0MSAxMy41NjcyIDcwLjE2MDIgMTMuNjc1MSA3MC4xNTgxIDEzLjczNzdDNzAuMTM4IDE0LjIyNTYgNzAuMTQ3IDE0LjcxNTYgNzAuMTQ3IDE1LjIyMkw3My41NjM4IDE1LjIyNDFaIiBmaWxsPSIjMzJBMDNEIi8+DQo8cGF0aCBkPSJNMC40Mzk0NTMgMTcuNzEwOEM0LjU3ODYzIDE1LjkwOTMgNy4zMDQ3NiAxMi45NjQyIDguMzU5MDcgOC40NzczNkg3Ljg4NTMxQzUuOTA2MSA4LjQ3NzM2IDMuOTI2MTkgOC40NzExNyAxLjk0Njk3IDguNDg5MDRDMS41OTA5OCA4LjQ4OTA0IDEuNDc4MDEgOC4zOTQxOSAxLjQ5NjUgOC4wMzQwNEMxLjUyNTk0IDcuNDQ3MDcgMS41MjI1MSA2Ljg1NzM2IDEuNDk2NSA2LjI3MDM5QzEuNDgyMTIgNS45Mzc3MyAxLjU3MjQ5IDUuODI5MTMgMS45MTk1OSA1LjgzMTE5QzMuOTkyNiA1Ljg0NyA2LjA2NjI5IDUuODMxMTkgOC4xMzkzMSA1Ljg0NTYzQzguNDUwOCA1Ljg0NTYzIDguNTM1NyA1Ljc2MzE1IDguNTMxNTkgNS40NTE4QzguNTEzMTEgNC4wMDg0MyA4LjUyNzQ4IDIuNTU4ODkgOC41MTEwNSAxLjExMjc3QzguNTA2OTQgMC43ODIxNzYgOC41OTggMC42OTU1NzMgOC45MzI3NyAwLjcyNTEyN0M5Ljg2NTIyIDAuODA4OTggMTAuODAxOCAwLjg0Njc4MiAxMS43Mzk3IDAuOTEyMDc3QzExLjg1NDcgMC45MjAzMjUgMTEuOTY1NiAwLjk4Njk5NiAxMi4wNzg2IDEuMDI2ODZDMTEuOTk3OCAxLjEzMTMzIDExLjkzODIgMS4yODY2NiAxMS44MzI4IDEuMzI5MjhDMTEuNjQxMSAxLjQwNjI2IDExLjYwMTQgMS41MjAzNSAxMS42MDI4IDEuNzA1MjRDMTEuNjA4OSAyLjk3NTQgMTEuNjE0NCA0LjI0ODMxIDExLjYwMjggNS41MTU3MkMxMS42MDI4IDUuNzkwNjQgMTEuNzA0OCA1Ljg0NDk0IDExLjk1NCA1Ljg0MzU3QzE0LjEzMjQgNS44MzUzMiAxNi4zMTE1IDUuODQzNTcgMTguNDkgNS44MzMyNkMxOC43ODk4IDUuODMzMjYgMTguOTAwOCA1Ljg4OTYyIDE4Ljg2OTMgNi4yMjQzNEMxOC43MTMyIDcuNjgwMDcgMTcuNzk5MiA4LjQ3NzM2IDE2LjIzNzYgOC40NzczNkMxNC45NDkyIDguNDc3MzYgMTMuNjYwNyA4LjQ3NzM2IDEyLjM3MjMgOC40NzczNkgxMS45MjQ1QzEzLjI5MzggMTIuNjgwMyAxNS42MDIzIDE1Ljk2NDMgMTkuODY2MSAxNy42Mjc2QzE4LjkzMjkgMTguMjM1MiAxNy45NjgzIDE4LjU0MTcgMTYuODg2NiAxOC40MDM2QzE1LjU1MyAxOC4yMzI0IDE0LjU0MTggMTcuNDcwMiAxMy41OTM2IDE2LjU4NzdDMTIuMjIxIDE1LjMwNTggMTEuMjY1OSAxMy43NDc3IDEwLjU1MjYgMTIuMDI2QzEwLjQ2MjkgMTEuODEwMiAxMC4zNzExIDExLjU5NSAxMC4yNjE2IDExLjMzNDVDMTAuMDU2MiAxMS44NjE3IDkuODY1OSAxMi4zNDk3IDkuNjY2NjggMTIuODMyMkM4LjgzODMgMTQuODM3MSA3LjQxMzYyIDE2LjMxOTYgNS42MzIyNSAxNy40OTc3QzQuNTkwMjcgMTguMTg1IDMuNDY3NSAxOC41NTA3IDIuMjE1MzQgMTguNDQwN0MxLjU3NjYgMTguMzgyMyAwLjk4MjM1MiAxOC4xOTI2IDAuNDM5NDUzIDE3LjcxMDhaIiBmaWxsPSIjMzJBMDNEIi8+DQo8cGF0aCBkPSJNMzguOTUwOSAwLjk0MTAzOUMzOC44ODkxIDEuMDE2OTcgMzguODM5OSAxLjE0MjYxIDM4Ljc2NDMgMS4xNjA1NkMzOC40MDU4IDEuMjQ2ODUgMzguNDU1NyAxLjUxMjYyIDM4LjQ1NjQgMS43Njk0MkMzOC40NTY0IDIuNzM1ODYgMzguNDY3NSAzLjcwNjQ0IDM4LjQ1MTYgNC42NzQ5NUMzOC40NDY3IDQuOTUxMDggMzguNTIwOSA1LjA3NzQxIDM4LjgwNTkgNS4wNDM1OEMzOC44NzcxIDUuMDM5NDQgMzguOTQ4NCA1LjAzOTQ0IDM5LjAxOTUgNS4wNDM1OEMzOS42NzI3IDUuMDQzNTggMzkuNzAwNSA1LjA3MjU4IDM5LjU2MzIgNS43MjQ5M0MzOS40MzQ5IDYuMzM0NDcgMzkuMTcgNi44NTI5IDM4LjYwMDcgNy4xODQ5NEMzOC41MTI2IDcuMjM2NzIgMzguNDYyIDcuNDE2ODkgMzguNDU4NSA3LjUzNzY5QzM4LjQ1MyAxMC40Nzg0IDM4LjQ1MyAxMy40MTkgMzguNDU4NSAxNi4zNTkyQzM4LjQ1ODUgMTYuNTcxOSAzOC40NTg1IDE2Ljc4NDUgMzguNDUwOSAxNi45OTcxQzM4LjQwNjUgMTguMTc4MiAzNy45MzkxIDE4Ljc2MzYgMzYuNzg2NiAxOC45ODkzQzM2LjI2NjYgMTkuMDkxNSAzNS43Mjc4IDE5LjEwNjcgMzUuMTk1OSAxOS4xMzQzQzM1LjA4ODQgMTkuMTM5OCAzNC45MDUzIDE5LjA0NTMgMzQuODc0OCAxOC45NTY5QzM0LjY1MjkgMTguMzEyOCAzNC40NTg4IDE3LjY1NzcgMzQuMjYxMSAxNy4wMDYxQzM0LjI1NTYgMTYuOTg2NyAzNC4yNjk1IDE2Ljk2MjYgMzQuMjc1NyAxNi45MzIyQzM0Ljc2ODcgMTYuOTMyMiAzNS4yNjMyIDE2LjkxNzcgMzUuNzU2MiAxNi45Mzc3QzM2LjA4NzcgMTYuOTUwOCAzNi4yMzQgMTYuODQzMSAzNi4yMjc3IDE2LjQ5NTlDMzYuMjExOCAxNS41OTg1IDM2LjIxOTQgMTQuNzAxMSAzNi4yMTU5IDEzLjgwMzdDMzYuMjEwNSAxMy43NTcgMzYuMjAxMyAxMy43MTA4IDM2LjE4ODIgMTMuNjY1NkwzNC42NzMgMTQuMTc4NUMzNC4zMzA1IDEyLjQ3NzYgMzMuOTk0MiAxMC44MDkxIDMzLjY0ODggOS4wOTY0M0wzNS4zNzQ4IDguNTc1MjRMMzYuMjAzNSAxMS42MzMzVjcuMjM2NzJIMzMuMjIxN0MzMy45ODQ1IDYuNjc1NDkgMzMuOTA1NCA1Ljg0NzExIDM0LjAxNyA1LjA0Mjg5SDM2LjIxOTRWNC41NzgzMUMzNi4yMTk0IDMuNDMzMDggMzYuMjI3NyAyLjI4NzE1IDM2LjIxMzkgMS4xNDE5MkMzNi4yMDk3IDAuODI1MDY2IDM2LjI5NTcgMC42OTczNTcgMzYuNjM0OCAwLjcyMjg5OUMzNy4zODg1IDAuNzc5NTA1IDM4LjE0NTEgMC44MDU3MzcgMzguOTAwMiAwLjg0NDM5NUwzOC45NTA5IDAuOTQxMDM5WiIgZmlsbD0iIzMyQTAzRCIvPg0KPHBhdGggZD0iTTIzLjU4OSAxOS4xMzQ1VjEyLjYzMTRDMjMuMzIzOCAxMy4xNDM0IDIzLjAyMzMgMTMuNDc2OSAyMi41NzQ0IDEzLjYzODJDMjIuMTM2NSAxMy43OTYyIDIxLjY1ODYgMTMuODA1MSAyMS4yMTUxIDEzLjY2MzdDMjIuNDAxIDExLjU3MzYgMjMuMTI0OSA5LjM2NTY3IDIzLjU0MzQgNi45Njg5M0gyMi4xMjgyQzIxLjYwMzMgNi45Njg5MyAyMS42MDMzIDYuOTY4OTMgMjEuNjAxOSA2LjQ2MzEyQzIxLjYwMTkgNi4wMDM0OCAyMS42MDYgNS41NDMxNiAyMS41OTg0IDUuMDg0OUMyMS41OTg0IDQuODc4MTYgMjEuNjY3NSA0Ljc4OTI3IDIxLjg4ODUgNC43OTQ3OEMyMi4zMjU3IDQuODA2NDkgMjIuNzY0MyA0Ljc3NzU1IDIzLjIwMDkgNC44MDIzNkMyMy41MTAzIDQuODE5NTkgMjMuNTc1OSA0LjY5NTU1IDIzLjU3MjQgNC40MTQzOUMyMy41NTkzIDMuMzA1NjEgMjMuNTcyNCAyLjE5NzUxIDIzLjU2MjEgMS4wODg3M0MyMy41NjIxIDAuNzk5OTkxIDIzLjYzNTMgMC42OTU5MzYgMjMuOTQ2MSAwLjcyNDE5QzI0LjY2MSAwLjc4ODk2NiAyNS4zNzkzIDAuODE1MTUzIDI2LjE4OTUgMC44NjIwMTJDMjYuMDcyMSAxLjAxMjkzIDI2LjAxODkgMS4xNTI4MiAyNS45Mjg0IDEuMTgzODNDMjUuNjg2IDEuMjY4NTkgMjUuNjYxOCAxLjQyNjQgMjUuNjY0NiAxLjY0NzZDMjUuNjc1NiAyLjU5MDMxIDI1LjY3NzcgMy41MzQzOSAyNS42NjQ2IDQuNDc3MUMyNS42NjQ2IDQuNzI0NDkgMjUuNzMzNiA0LjgxNDA3IDI1Ljk4MzcgNC44MDIzNkMyNi4zNjAxIDQuNzg0NDQgMjYuNzM3OSA0Ljc5NzU0IDI3LjEwNzUgNC43OTc1NEMyNy4zNDU3IDUuNjEyMDcgMjYuODM1MyA2LjU5MjY3IDI2LjAwMjMgNi44ODQxN0MyNS43MjYxIDYuOTgxMzMgMjUuNjc0MiA3LjExNzc4IDI1LjY2MTEgNy4zODU4NEMyNS41OTk3IDguNjI2MjUgMjYuMjEzNyA5LjU5OTI3IDI2Ljg5MDYgMTAuNTQ4MkMyNy4wOTc4IDEwLjgzNDIgMjcuMzMyNiAxMS4wOTQ2IDI3LjU1NTcgMTEuMzY2OEMyNy4xMjMzIDExLjY0MjUgMjYuNTcxNSAxMS41MTI5IDI1LjY3MDEgMTAuOTA5M1YxMS4yNzA0QzI1LjY3MDEgMTMuMTA4IDI1LjY3MDEgMTQuOTQ3NSAyNS42NzAxIDE2Ljc4ODhDMjUuNjcwMSAxNy45NzY4IDI1LjAzMDUgMTguODM0OCAyMy45NjIgMTkuMDg4NEMyMy44Mzg2IDE5LjExMDIgMjMuNzE0MSAxOS4xMjU2IDIzLjU4OSAxOS4xMzQ1WiIgZmlsbD0iIzMyQTAzRCIvPg0KPHBhdGggZD0iTTMxLjQ3NjkgNS40ODI3NkgzMy4yNDhDMzMuMzY4MSA2LjM1NTc3IDMyLjg5NzEgNy4xMDU4NiAzMi4xMTc1IDcuMzAyNDFDMzEuOTAzNyA3LjM1NzU1IDMxLjY4NDQgNy4zODY2OSAzMS40NjQgNy4zODkyMkMyOS45MjEgNy4zOTg5NCAyOC4zNzcyIDcuMzk3NTYgMjYuODM0MiA3LjM5NzU2QzI2Ljc1NjggNy4zOTc1NiAyNi42Nzk1IDcuMzgwMTkgMjYuNTQ0NCA3LjM2NDIyQzI2LjYwMTMgNy4zMDcyOCAyNi42NjExIDcuMjUzNSAyNi43MjM2IDcuMjAzMDlDMjcuMjE0MiA2Ljg2MTM4IDI3LjQ5NzggNi4zODk4MSAyNy41Mzc4IDUuNzg0MThDMjcuNTU0MSA1LjUzODMyIDI3LjY0OTggNS40NjA1NCAyNy44ODEyIDUuNDY3NDhDMjguMjk4NSA1LjQ3OTI5IDI4LjcxNjUgNS40NjE5MyAyOS4xMzQ1IDUuNDY3NDhDMjkuMzI5OSA1LjQ2NzQ4IDI5LjQzOTkgNS40MDc3NiAyOS40Mjk3IDUuMTgyNzNDMjkuNDE4MSA0LjkyNDM3IDI5LjQyOTcgNC42NjUzMSAyOS40Mjk3IDQuMzY1OThDMjguNzYyIDQuMzY1OTggMjguMTI2MiA0LjM1IDI3LjQ5MjQgNC4zNzI5MkMyNy4xNzYyIDQuMzg0MDMgMjcuMDU0NyA0LjI4ODg4IDI3LjA2OTYgMy45NTYyMUMyNy4wOTIgMy40NjE3MSAyNy4wNzU3IDIuOTY1MTMgMjcuMDc1NyAyLjQyODI2QzI3Ljc0MjggMi40MjgyNiAyOC4zNjUgMi40MDY3NCAyOC45ODc5IDIuNDM2NkMyOS4zNDAxIDIuNDUzMjcgMjkuNDY5IDIuMzUwNDggMjkuNDM3MSAxLjk4MzA4QzI5LjQxMiAxLjYzOTU0IDI5LjQxMiAxLjI5NDU2IDI5LjQzNzEgMC45NTEwMjJDMjkuNDQyNiAwLjg2Njk4NSAyOS41NTMyIDAuNzE3NjY1IDI5LjYxMTUgMC43MTk3NDhDMzAuMzgzMSAwLjc0MzM2MiAzMS4xNTQ2IDAuNzg5MTk5IDMyLjAxOTggMC44MzM2NDhDMzEuOTE0NiAwLjk4NDM1OSAzMS44NzQ1IDEuMTExNDYgMzEuODA2IDEuMTI4MTJDMzEuNDcyMiAxLjIyNjc1IDMxLjQ2NjcgMS40NzE5MSAzMS40NzI4IDEuNzYwODNDMzEuNDkxMiAyLjQ3NjE5IDMxLjM1NDEgMi40Mjg5NiAzMi4xMjA5IDIuNDI2ODhDMzIuNzA5MiAyLjQyNjg4IDMzLjI5ODIgMi40MjY4OCAzMy44ODExIDIuNDI2ODhDMzMuOTExNSAyLjY1MDI0IDMzLjg5NzkgMi44Nzc1OCAzMy44NDA5IDMuMDk1NDVDMzMuNzg0IDMuMzEzMzEgMzMuNjg0OSAzLjUxNzI3IDMzLjU0OTYgMy42OTUyM0MzMy40MTQyIDMuODczMiAzMy4yNDU0IDQuMDIxNTYgMzMuMDUzIDQuMTMxNTJDMzIuODYwNiA0LjI0MTQ5IDMyLjY0ODYgNC4zMTA4MiAzMi40Mjk2IDQuMzM1NDJDMzIuMzQ4OSA0LjM0NTE0IDMyLjI2NzQgNC4zNDg2MSAzMi4xODY3IDQuMzU2MjVDMzEuNDcyOCA0LjQyMTU0IDMxLjQ3MjggNC40MjE1NCAzMS40NzU1IDUuMTUwNzhDMzEuNDc3NiA1LjIzNjIxIDMxLjQ3NjkgNS4zMjY1IDMxLjQ3NjkgNS40ODI3NloiIGZpbGw9IiMzMkEwM0QiLz4NCjxwYXRoIGQ9Ik0zMy41MTkxIDEyLjc4OTFIMzAuMTM4OUMyOS4zOTk0IDEyLjc4OTEgMjguNjU5OSAxMi43ODA5IDI3LjkyMDMgMTIuNzkzOEMyNy42NjkyIDEyLjc5NzkgMjcuNTU0OCAxMi43MzggMjcuNTU2MiAxMi40NjgyQzI3LjU2NTkgMTEuMTA1OCAyNy41NjU5IDkuNzQzMzEgMjcuNTU2MiA4LjM4MDg3QzI3LjU1NjIgOC4xNTgxMSAyNy42MzU3IDguMDcxNTkgMjcuODY4IDguMDcyMjdDMjkuNjU2OCA4LjA3OTk5IDMxLjQ0NTggOC4wODE1OCAzMy4yMzUxIDguMDc3MDRDMzMuNDczIDguMDc3MDQgMzMuNTUyNSA4LjE2ODMyIDMzLjU1MjUgOC4zODE1NUMzMy41NTI1IDkuNzg5NDEgMzMuNTU0OSAxMS4xOTg0IDMzLjU1OTUgMTIuNjA4NUMzMy41NTE4IDEyLjY2OTggMzMuNTM4MiAxMi43MzAyIDMzLjUxOTEgMTIuNzg5MVYxMi43ODkxWk0yOS41NTQzIDkuNzQ2NzFDMjkuNTU0MyAxMC4xODI3IDI5LjU0OCAxMC41NzY0IDI5LjU2MDUgMTAuOTY4OEMyOS41NjA1IDExLjAyNTQgMjkuNjQ5OCAxMS4xMjYyIDI5LjcwMDEgMTEuMTI2OUMzMC4yODk2IDExLjEzNzggMzAuODc5OCAxMS4xMzQ0IDMxLjQ4NCAxMS4xMzQ0QzMxLjQ4NCAxMC43MTY4IDMxLjQ3NzcgMTAuMzU2NCAzMS40ODQgOS45OTYwNEMzMS40ODg5IDkuODE1NTIgMzEuNDE0MiA5Ljc0Mzk5IDMxLjIzNDIgOS43NDUzNUMzMC42ODggOS43NDk0NCAzMC4xNDEgOS43NDY3MSAyOS41NTQzIDkuNzQ2NzFaIiBmaWxsPSIjMzJBMDNEIi8+DQo8cGF0aCBkPSJNMzIuNTY3NSAxNS41NDY3TDMzLjg2NDYgMTUuMzgxOUMzNC4wMzg3IDE2LjQyNzYgMzMuNSAxNy4zMDMgMzIuNDU4MyAxNy41MTU3QzMxLjAxODYgMTcuODA5NyAyOS41NzYxIDE4LjA5MjkgMjguMTM0MyAxOC4zNzY3QzI3LjkwNyAxOC40MjEyIDI3LjY3NzYgMTguNDM4OSAyNy41NDA0IDE4LjY3MzVDMjcuNTA3NyAxOC43Mjg5IDI3LjQwMzkgMTguNzQxOSAyNy4yOTU0IDE4Ljc5NzNDMjcuMDQ0OCAxOC4wMTgzIDI2LjgwMzggMTcuMjY3NCAyNi41NDQ0IDE2LjQ2NjVDMjcuMTEwNCAxNi4zODU4IDI3LjYzNjcgMTYuMzEzMyAyOC4xNjAzIDE2LjIzNTRDMjguODc1NyAxNi4xMzAxIDI5LjU4OTEgMTYuMDExNyAzMC4zMDU5IDE1LjkxOEMzMC41MzggMTUuODg3MyAzMC42NTI3IDE1Ljc5MzYgMzAuNzA1OSAxNS41NjQ1QzMwLjg5NzEgMTQuNzMzNSAzMS4xMDM5IDEzLjkwNjcgMzEuMzA1MyAxMy4wNzg0TDMxLjM3MzYgMTIuNzkzOUwzMy42Nzc1IDEzLjU4MTFDMzMuNjI3IDEzLjY2MzIgMzMuNjA5MyAxMy43Mjg5IDMzLjU3OTkgMTMuNzM0M0MzMy4wODQzIDEzLjgyNTMgMzMuMDYwNCAxNC4yNjUgMzIuOTIxMiAxNC42MTg2QzMyLjgwNTggMTQuOTA3OSAzMi42OTkzIDE1LjE5OTMgMzIuNTY3NSAxNS41NDY3WiIgZmlsbD0iIzMyQTAzRCIvPg0KPHBhdGggZD0iTTI4LjE1NjYgMTYuMDk5M0MyNy45NDUgMTUuMjcwOSAyNy43NDIgMTQuNDk0NyAyNy41NTc2IDEzLjcxMzRDMjcuNTQzIDEzLjY0OTcgMjcuNjQwMiAxMy41MTQ2IDI3LjcxMiAxMy40OTIzQzI4LjE1NCAxMy4zNTY1IDI4LjYwMTIgMTMuMjMyOSAyOS4wNTMyIDEzLjEzMzVDMjkuMTM1IDEzLjExNTYgMjkuMzEyNyAxMy4yMTMxIDI5LjMzNjcgMTMuMjg5QzI5LjU0NTcgMTMuOTUyNCAyOS43MzYgMTQuNjIxNSAyOS45MTMxIDE1LjI5MzJDMjkuOTM0NCAxNS4zNzI4IDI5Ljg2NTggMTUuNTM5OCAyOS43OTkzIDE1LjU2MzRDMjkuMjU0OCAxNS43NTU4IDI4LjcwNTEgMTUuOTIyOCAyOC4xNTY2IDE2LjA5OTNaIiBmaWxsPSIjMzJBMDNEIi8+DQo8L3N2Zz4NCg==";
const _hoisted_1$j = { class: "gt-headline-header" };
const _hoisted_2$g = { class: "head-text" };
const _hoisted_3$e = { class: "gt-header" };
const _hoisted_4$a = { class: "title" };
const _hoisted_5$8 = {
  class: "gt-sidebar-content",
  id: "gtSidebarContentRef"
};
const _hoisted_6$4 = { class: "gt-menu-box" };
const _hoisted_7$3 = { class: "gt-bottomLogo" };
const _hoisted_8$2 = /* @__PURE__ */ createElementVNode("img", {
  style: { "width": "28.58px", "height": "28.09px" },
  src: _imports_0,
  alt: ""
}, null, -1);
const _hoisted_9$2 = {
  key: 0,
  style: { "width": "80px", "height": "18.41px" },
  src: _imports_1,
  alt: ""
};
const __default__$l = {
  name: "GLayout"
};
const _sfc_main$p = /* @__PURE__ */ Object.assign(__default__$l, {
  props: {
    headText: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    menuTabs: {
      type: Array,
      default: null
    },
    collapsed: {
      type: Boolean,
      default: false
    },
    onlyOneLevel: {
      type: Boolean,
      default: false
    }
  },
  emits: ["collapsed"],
  setup(__props, { emit }) {
    var _a2;
    const props = __props;
    const instance = getCurrentInstance();
    const isCollapsed = ref(props.collapsed);
    const Router = (_a2 = instance.appContext.config.globalProperties) == null ? void 0 : _a2.$router;
    const currentTab = computed(() => {
      var _a3;
      let { path } = Router.currentRoute.value;
      if (props.menuTabs && path) {
        return (_a3 = props.menuTabs.filter((item) => item.path == path)[0]) == null ? void 0 : _a3.name;
      }
      return null;
    });
    watch(
      () => Router.currentRoute.value.path,
      (val) => {
        var _a3;
        if (props.menuTabs && val && props.onlyOneLevel && instance.refs.layoutTabs) {
          let name = (_a3 = props.menuTabs.filter((item) => item.path == val)[0]) == null ? void 0 : _a3.name;
          if (name && instance.refs.layoutTabs) {
            instance.refs.layoutTabs.current = name;
          }
        }
      }
    );
    watch(
      () => props.menuTabs,
      (menuArr) => {
        if (instance.refs.layoutTabs && menuArr && menuArr.find((item) => item.path == Router.currentRoute.value.path)) {
          let target = menuArr.find(
            (item) => item.path == Router.currentRoute.value.path
          );
          instance.refs.layoutTabs.current = target.name;
        }
      }
    );
    const handleMenuTabCallback = (target = {}) => {
      let { path, query } = target;
      if (path && Router) {
        Router.push({
          path,
          query
        });
      } else {
        console.log("target is empty");
      }
    };
    const handleCollapsed = () => {
      let val = !isCollapsed.value;
      isCollapsed.value = val;
      emit("collapsed", val);
      if (instance.refs.layoutTabs) {
        instance.refs.layoutTabs.collapsed = val;
      }
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      const _component_g_title = resolveComponent("g-title");
      const _component_g_tabs = resolveComponent("g-tabs");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-wrapper", isCollapsed.value ? "collapsed" : ""])
      }, [
        createElementVNode("div", _hoisted_1$j, [
          createElementVNode("div", {
            class: "gt-headline",
            style: normalizeStyle({
              width: isCollapsed.value ? "100px" : "290px"
            })
          }, [
            createVNode(_component_g_icon, {
              name: "menu",
              onClick: handleCollapsed
            }),
            createElementVNode("div", _hoisted_2$g, toDisplayString(__props.headText), 1)
          ], 4),
          createElementVNode("div", _hoisted_3$e, [
            createElementVNode("div", _hoisted_4$a, [
              createVNode(_component_g_title, { level: 1 }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(__props.title), 1)
                ]),
                _: 1
              })
            ]),
            renderSlot(_ctx.$slots, "header")
          ])
        ]),
        createElementVNode("div", _hoisted_5$8, [
          createElementVNode("div", {
            class: normalizeClass(["gt-sidebar", __props.onlyOneLevel ? "onlyOneLevel" : ""])
          }, [
            createElementVNode("div", _hoisted_6$4, [
              renderSlot(_ctx.$slots, "sidebar"),
              createElementVNode("div", _hoisted_7$3, [
                createElementVNode("div", null, [
                  _hoisted_8$2,
                  !isCollapsed.value ? (openBlock(), createElementBlock("img", _hoisted_9$2)) : createCommentVNode("", true)
                ])
              ])
            ])
          ], 2),
          createElementVNode("div", {
            id: "gtContentRef",
            class: "gt-content-wrapper",
            style: normalizeStyle({
              width: isCollapsed.value ? "calc(100% - 100px)" : "calc(100% - 280px)"
            })
          }, [
            __props.onlyOneLevel && __props.menuTabs && __props.menuTabs.length > 0 ? (openBlock(), createBlock(_component_g_tabs, {
              key: 0,
              ref: "layoutTabs",
              name: "layoutTab",
              class: "gt-route-tabs",
              tabs: __props.menuTabs,
              clickCallback: handleMenuTabCallback,
              currentTab: unref(currentTab),
              layoutMode: true,
              collapsed: isCollapsed.value
            }, null, 8, ["tabs", "currentTab", "collapsed"])) : createCommentVNode("", true),
            createElementVNode("div", {
              class: "gt-content",
              style: normalizeStyle({
                height: __props.onlyOneLevel && __props.menuTabs && __props.menuTabs.length > 0 ? "calc(100vh - 125px)" : "calc(100vh - 80px)"
              })
            }, [
              renderSlot(_ctx.$slots, "content")
            ], 4)
          ], 4)
        ])
      ], 2);
    };
  }
});
const __default__$k = {
  name: "GTitle"
};
const _sfc_main$o = /* @__PURE__ */ Object.assign(__default__$k, {
  props: {
    level: {
      type: Number,
      default: 0
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-level" + __props.level, "gt-title"])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
_sfc_main$o.install = function(Vue) {
  Vue.component(_sfc_main$o.name, _sfc_main$o);
};
const _hoisted_1$i = { class: "gt-tabs-content" };
const _hoisted_2$f = ["id"];
const _hoisted_3$d = ["onClick"];
const __default__$j = {
  name: "GTabs"
};
const _sfc_main$n = /* @__PURE__ */ Object.assign(__default__$j, {
  props: {
    name: {
      type: String
    },
    tabs: {
      type: Array,
      default: [{ name: "tab1" }, { name: "tab2" }]
    },
    currentTab: {
      type: String,
      default: null
    },
    clickCallback: {
      type: Function
    },
    layoutMode: {
      type: Boolean,
      default: false
    },
    collapsed: {
      type: Boolean
    }
  },
  setup(__props, { expose }) {
    var _a2;
    const props = __props;
    const instance = getCurrentInstance();
    const Router = (_a2 = instance.appContext.config.globalProperties) == null ? void 0 : _a2.$router;
    const slots = useSlots();
    const slotTabs = Object.keys(slots);
    const current = ref(props.currentTab || slotTabs[0]);
    const collapsed = ref(props.collapsedFromParent);
    const parentWidth = ref(null);
    expose({
      collapsed,
      current
    });
    const handleTabChange = (name) => {
      current.value = name;
      if (props.clickCallback) {
        let toTab = props.tabs.filter((item) => item.name == name)[0] || {};
        props.clickCallback(toTab);
      }
    };
    const tabRef = ref(null);
    const { width } = useElementBounding(tabRef);
    const widthTabs = ref(width.value);
    const isMouseIn = ref(false);
    const classComputed = computed(() => {
      let arr = [];
      if (isMouseIn.value) {
        arr.push("mouse-in");
      }
      if (props.layoutMode) {
        arr.push("layoutMode");
      }
      if (parentWidth.value && parseInt(widthTabs.value) > parentWidth.value) {
        arr.push("overTabsWrapper");
      }
      return arr;
    });
    const styleComputed = computed(() => {
      return props.layoutMode ? {
        "max-width": "calc(100% - 20px)"
      } : {};
    });
    const calcTargetWidth = () => {
      let target = document.getElementById("gtContentRef");
      let target2 = document.getElementById(`${props.name}-tabRef`);
      if (props.name == "layoutTab" && target && target2) {
        parentWidth.value = target.offsetWidth;
        widthTabs.value = target2.offsetWidth;
      }
    };
    watch(
      () => current.value,
      (nVal) => {
        setTimeout(() => {
          calcTargetWidth();
        }, 200);
      }
    );
    watch(
      () => Router.currentRoute.value.path,
      (val) => {
        setTimeout(() => {
          calcTargetWidth();
        }, 1e3);
      }
    );
    onMounted(() => {
      setTimeout(() => {
        calcTargetWidth();
      }, 200);
      window.addEventListener("resize", calcTargetWidth);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-tabs-wrapper", unref(classComputed)]),
        onMouseenter: _cache[0] || (_cache[0] = ($event) => isMouseIn.value = true),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => isMouseIn.value = false),
        style: normalizeStyle(unref(styleComputed))
      }, [
        createElementVNode("div", _hoisted_1$i, [
          createElementVNode("div", {
            class: "tabs",
            id: __props.name ? `${__props.name}-tabRef` : "",
            ref_key: "tabRef",
            ref: tabRef
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.tabs, (tab) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(["tab", current.value == tab.name ? "current" : ""]),
                key: tab.name,
                onClick: () => {
                  handleTabChange(tab.name);
                }
              }, toDisplayString(tab.name), 11, _hoisted_3$d);
            }), 128))
          ], 8, _hoisted_2$f)
        ]),
        createElementVNode("div", {
          class: normalizeClass(unref(slotTabs).includes(current.value) ? "content" : "")
        }, [
          unref(slotTabs).includes(current.value) ? renderSlot(_ctx.$slots, current.value, { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [], 64))
        ], 2)
      ], 38);
    };
  }
});
_sfc_main$n.install = function(Vue) {
  Vue.component(_sfc_main$n.name, _sfc_main$n);
};
_sfc_main$p.install = function(Vue) {
  Vue.component(_sfc_main$p.name, _sfc_main$p);
};
const _hoisted_1$h = {
  key: 0,
  class: "gt-loading-wrapper"
};
const _hoisted_2$e = /* @__PURE__ */ createElementVNode("div", { class: "gt-loadBox gt-relative" }, [
  /* @__PURE__ */ createElementVNode("div", { class: "gt-loadAni" }),
  /* @__PURE__ */ createElementVNode("div", { class: "gt-loadText" }, "\u8F09\u5165\u4E2D")
], -1);
const _hoisted_3$c = [
  _hoisted_2$e
];
const __default__$i = {
  name: "GLoading"
};
const _sfc_main$m = /* @__PURE__ */ Object.assign(__default__$i, {
  setup(__props) {
    const instance = getCurrentInstance();
    const gLoadingShow = ref(false);
    instance.appContext.config.globalProperties.handleLoadingTrigger = ({
      time = 3e3
    } = {}) => {
      time = typeof parseInt(time) == "number" ? parseInt(time) : 3e3;
      gLoadingShow.value = true;
      setTimeout(() => {
        gLoadingShow.value = false;
      }, time);
    };
    return (_ctx, _cache) => {
      return gLoadingShow.value ? (openBlock(), createElementBlock("div", _hoisted_1$h, _hoisted_3$c)) : createCommentVNode("", true);
    };
  }
});
_sfc_main$m.install = function(Vue) {
  Vue.component(_sfc_main$m.name, _sfc_main$m);
};
const _hoisted_1$g = ["onClick", "onMouseleave"];
const _hoisted_2$d = ["onMouseenter"];
const _hoisted_3$b = { key: 0 };
const _hoisted_4$9 = {
  key: 0,
  class: "line"
};
const _hoisted_5$7 = ["onClick"];
const __default__$h = {
  name: "GMenu"
};
const _sfc_main$l = /* @__PURE__ */ Object.assign(__default__$h, {
  props: {
    active: {
      type: String
    },
    activePath: {
      type: String,
      default: "/"
    },
    menu: {
      type: Array,
      default: []
    },
    collapsed: {
      type: Boolean,
      default: false
    },
    onlyOneLevel: {
      type: Boolean,
      default: false
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const instance = getCurrentInstance();
    const collapsed = computed(() => {
      return props.collapsed;
    });
    const activePath = computed(() => {
      var _a2;
      return props.onlyOneLevel ? "/" + ((_a2 = props.activePath) == null ? void 0 : _a2.split("/")[1]) : props.activePath;
    });
    const rootPath = computed(() => {
      var _a2;
      let result2 = "/" + ((_a2 = props.activePath) == null ? void 0 : _a2.split("/")[1]);
      return result2;
    });
    const onlyOneLevel = ref(props.onlyOneLevel);
    const isCollapsedAndHadOpenedOne = ref(false);
    const menu = ref(
      props.menu.map((item, idx) => {
        return {
          ...item,
          children: item.children ? item.children.map((cItem, cIdx) => {
            return {
              ...cItem,
              uuid: v4()
            };
          }) : []
        };
      })
    );
    watch(
      () => props.menu,
      (val) => {
        if (props.menu) {
          menu.value = props.menu.map((item, idx) => {
            return {
              ...item,
              children: item.children ? item.children.map((cItem, cIdx) => {
                return {
                  ...cItem,
                  uuid: v4()
                };
              }) : []
            };
          });
        }
      },
      { deep: true }
    );
    const findRouteIndexByPath = () => {
      let routerMenuIndex = null;
      let groupIndex = null;
      let activeItemIndex = null;
      menu.value.forEach((item, idx) => {
        if (Array.isArray(item.children)) {
          item.children.forEach((cItem, cIdx) => {
            if (cItem.path === activePath.value) {
              groupIndex = idx + 1;
              activeItemIndex = cItem.uuid;
              routerMenuIndex = `${idx + 1}-${cIdx + 1}`;
            }
          });
        }
      });
      return {
        routerMenuIndex,
        groupIndex,
        activeItemIndex
      };
    };
    const result = reactive(findRouteIndexByPath());
    const setActiveInfo = () => {
      var _a2, _b;
      return {
        menuGroupActiveArr: collapsed.value ? [] : result.routerMenuIndex ? [result.groupIndex] : [parseInt((_a2 = props.active) == null ? void 0 : _a2.split("-")[0])],
        menuGroupActive: collapsed.value ? [] : result.groupIndex ? result.groupIndex : parseInt((_b = props.active) == null ? void 0 : _b.split("-")[0]),
        menuGroupItemActive: result.activeItemIndex || ""
      };
    };
    const info = reactive(setActiveInfo());
    const menuComputed = computed(() => {
      return menu.value.map((item, idx) => {
        return {
          ...item,
          active: info.menuGroupActiveArr.includes(idx + 1) ? true : false,
          children: item.children || []
        };
      });
    });
    const handleGroupClick = (item, gIdx) => {
      const Router = instance.appContext.config.globalProperties.$router || null;
      let { active, path, children } = item;
      if (path && children.length === 0) {
        if (Router) {
          Router.push(item);
        }
      } else if (onlyOneLevel.value) {
        if (Router) {
          if (Router.currentRoute.value.meta.title != item.label) {
            Router.push(item.children[0]);
          }
        }
      } else if (!active) {
        info.menuGroupActive = gIdx + 1;
        info.menuGroupActiveArr = collapsed.value ? [gIdx + 1] : [...info.menuGroupActiveArr, gIdx + 1];
        isCollapsedAndHadOpenedOne.value = collapsed.value ? gIdx + 1 : false;
      } else {
        info.menuGroupActiveArr = info.menuGroupActiveArr.filter(
          (i) => i != gIdx + 1
        );
        isCollapsedAndHadOpenedOne.value = false;
      }
    };
    const handleMenuGroupMouseenter = (item, gIdx) => {
      let { active } = item;
      if (collapsed.value && !active) {
        info.menuGroupActive = gIdx + 1;
        info.menuGroupActiveArr = [gIdx + 1];
        isCollapsedAndHadOpenedOne.value = gIdx + 1;
      }
    };
    const handleMenuGroupMouseleave = (item, gIdx) => {
      if (collapsed.value) {
        info.menuGroupActive = [];
        info.menuGroupActiveArr = [];
        isCollapsedAndHadOpenedOne.value = false;
      }
    };
    const handleRouteTo = (path, gIdx, cItemUuid, cItem) => {
      let arr = [.../* @__PURE__ */ new Set([...info.menuGroupActiveArr, gIdx + 1])];
      info.menuGroupActive = gIdx + 1;
      info.menuGroupItemActive = cItemUuid;
      info.menuGroupActiveArr = arr;
      if (path && instance.appContext.config.globalProperties.$router) {
        instance.appContext.config.globalProperties.$router.push(cItem);
      }
    };
    expose({
      collapsed,
      onlyOneLevel,
      activePath
    });
    const handleChildBoxMouseleave = () => {
      if (collapsed.value) {
        handleMenuClose();
      }
    };
    const handleMenuClose = () => {
      isCollapsedAndHadOpenedOne.value = false;
      info.menuGroupActiveArr = [];
    };
    watch(
      () => isCollapsedAndHadOpenedOne.value,
      (val) => {
        var _a2;
        if (val && document.getElementsByTagName("html")[0]) {
          document.getElementsByTagName("html")[0].addEventListener("click", handleMenuClose, false);
        } else {
          (_a2 = document.getElementsByTagName("html")[0]) == null ? void 0 : _a2.removeEventListener("click", handleMenuClose);
        }
      }
    );
    watch(
      () => collapsed.value,
      (val) => {
        if (val) {
          info.menuGroupActiveArr = [];
          info.menuGroupActive = [];
        } else {
          Object.assign(result, findRouteIndexByPath());
          Object.assign(info, setActiveInfo());
        }
      }
    );
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-menus", unref(collapsed) ? "collapsed" : ""])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(menuComputed), (item, index2) => {
          var _a2;
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["gt-menu-group", item.active ? "active" : ""]),
            key: "group" + item.label,
            onClick: withModifiers(($event) => handleGroupClick(item, index2), ["stop"]),
            onMouseleave: ($event) => handleMenuGroupMouseleave()
          }, [
            createElementVNode("div", {
              class: normalizeClass(["menu-text", {
                active: unref(activePath) ? item.path == unref(activePath) ? true : unref(collapsed) && !onlyOneLevel.value && ((_a2 = item.path) == null ? void 0 : _a2.startsWith(unref(rootPath))) ? true : false : false
              }])
            }, [
              createElementVNode("div", {
                class: "left",
                onMouseenter: ($event) => handleMenuGroupMouseenter(item, index2)
              }, [
                createElementVNode("div", {
                  class: normalizeClass(["iconBox", unref(collapsed) ? "collapesed" : ""])
                }, [
                  item.icon || unref(collapsed) || item.iconClasses ? (openBlock(), createBlock(_component_g_icon, {
                    key: 0,
                    name: item.icon ? item.icon : item.iconClasses ? "menuIconName" : "items",
                    classes: item.iconClasses,
                    size: "md"
                  }, null, 8, ["name", "classes"])) : createCommentVNode("", true)
                ], 2),
                !unref(collapsed) ? (openBlock(), createElementBlock("span", _hoisted_3$b, toDisplayString(item.label), 1)) : createCommentVNode("", true)
              ], 40, _hoisted_2$d),
              item.children.length > 0 && !unref(collapsed) && !onlyOneLevel.value ? (openBlock(), createBlock(_component_g_icon, {
                key: 0,
                name: "chevron-up",
                style: normalizeStyle(item.active ? {} : { transform: "rotate(180deg)" }),
                size: "md",
                class: "group-icon"
              }, null, 8, ["style"])) : createCommentVNode("", true)
            ], 2),
            item.children.length > 0 && !onlyOneLevel.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([
                "childBox",
                !unref(collapsed) ? item.active ? "open" : "" : info.menuGroupActive == index2 + 1 ? "open tp-aniIn-NoTran" : "tp-aniOut-Notran"
              ]),
              style: normalizeStyle(
                item.active ? {
                  height: unref(collapsed) ? `${item.children.length * 40 < 45 ? "45" : item.children.length * 40}px` : `${item.children.length * 44 + 40 < 85 ? "85" : item.children.length * 44 + 40}px`
                } : { height: `0px` }
              ),
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onMouseleave: handleChildBoxMouseleave
            }, [
              !unref(collapsed) ? (openBlock(), createElementBlock("div", _hoisted_4$9)) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(item.children, (cItem, cIndex) => {
                return openBlock(), createElementBlock("div", {
                  key: cItem.uuid,
                  class: normalizeClass([
                    "gt-menu-group-item",
                    unref(activePath) ? cItem.path == unref(activePath) ? "active" : "" : info.menuGroupItemActive == cItem.uuid ? "active" : ""
                  ]),
                  onClick: withModifiers(
                    () => {
                      handleRouteTo(cItem.path, index2, cItem.uuid, cItem);
                    },
                    ["stop"]
                  )
                }, [
                  cItem.icon || cItem.iconClasses ? (openBlock(), createBlock(_component_g_icon, {
                    key: 0,
                    name: cItem.icon || "childIconName",
                    classes: cItem.iconClasses,
                    size: "md",
                    class: "child-icon"
                  }, null, 8, ["name", "classes"])) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(cItem.label), 1)
                ], 10, _hoisted_5$7);
              }), 128))
            ], 38)) : createCommentVNode("", true)
          ], 42, _hoisted_1$g);
        }), 128))
      ], 2);
    };
  }
});
_sfc_main$l.install = function(Vue) {
  Vue.component(_sfc_main$l.name, _sfc_main$l);
};
const _hoisted_1$f = {
  key: 0,
  class: "gt-msgBox"
};
const _hoisted_2$c = { class: "gt-relative" };
const _hoisted_3$a = {
  key: 0,
  class: "title"
};
const __default__$g = {
  name: "GMessage"
};
const _sfc_main$k = /* @__PURE__ */ Object.assign(__default__$g, {
  setup(__props) {
    const instance = getCurrentInstance();
    const msgArr = reactive({
      arr: []
    });
    const isFinished = ref(false);
    const TYPES = ["info", "warning", "error"];
    const list = computed(() => {
      return msgArr.arr;
    });
    instance.appContext.config.globalProperties.handleMessageTrigger = ({
      msg,
      type = "info",
      title = ""
    } = {}) => {
      isFinished.value = false;
      msgArr.arr = msgArr.arr.filter((item) => item.show);
      let obj = {
        id: v4(),
        msgType: TYPES.includes(type) ? type : TYPES[0],
        classArr: ["gt-msg", TYPES.includes(type) ? type : TYPES[0], "aniIn"],
        msgTitle: title,
        msgText: msg || v4(),
        show: true
      };
      msgArr.arr = [...msgArr.arr, obj];
      setTimeout(() => {
        msgArr.arr = msgArr.arr.map((item) => {
          if (item.id == obj.id) {
            return {
              ...item,
              classArr: item.classArr.map(
                (cItem) => cItem == "aniIn" ? "aniOut" : cItem
              ),
              aniEndStart: new Date().getTime(),
              show: false
            };
          }
          return item;
        });
        if (msgArr.arr.filter((item) => item.show).length == 0) {
          setTimeout(() => {
            if (new Date().getTime() - msgArr.arr[msgArr.arr.length - 1].aniEndStart > 1200) {
              isFinished.value = true;
            }
          }, 1200);
        }
      }, 1e3 + msgArr.arr.length * 500);
    };
    return (_ctx, _cache) => {
      return !isFinished.value ? (openBlock(), createElementBlock("div", _hoisted_1$f, [
        createElementVNode("div", _hoisted_2$c, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(list), (item) => {
            return openBlock(), createElementBlock("div", {
              key: item.id,
              class: normalizeClass(item.classArr)
            }, [
              item.msgTitle ? (openBlock(), createElementBlock("div", _hoisted_3$a, toDisplayString(item.msgTitle), 1)) : createCommentVNode("", true),
              createTextVNode(" " + toDisplayString(item.msgText), 1)
            ], 2);
          }), 128))
        ])
      ])) : createCommentVNode("", true);
    };
  }
});
_sfc_main$k.install = function(Vue) {
  Vue.component(_sfc_main$k.name, _sfc_main$k);
};
const __default__$f = {
  name: "GMessageToast"
};
const _sfc_main$j = /* @__PURE__ */ Object.assign(__default__$f, {
  props: {
    text: {
      type: String,
      default: "\u5132\u5B58\u6210\u529F!"
    }
  },
  setup(__props) {
    const isShow = ref(false);
    const isFinished = ref(false);
    const instance = getCurrentInstance();
    instance.appContext.config.globalProperties.handleMessageToastTrigger = ({
      time = 1200
    }) => {
      if (!isShow.value) {
        isShow.value = true;
        setTimeout(() => {
          isShow.value = false;
          isFinished.value = true;
        }, time);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-message-toast", isShow.value ? "gt-ani-toast-in" : isFinished.value ? "gt-ani-toast-out" : ""])
      }, [
        createElementVNode("span", null, toDisplayString(__props.text), 1)
      ], 2);
    };
  }
});
_sfc_main$j.install = function(Vue) {
  Vue.component(_sfc_main$j.name, _sfc_main$j);
};
const _hoisted_1$e = ["onClick"];
const _hoisted_2$b = { class: "gt-option-content" };
const _hoisted_3$9 = { class: "gt-option-prefix" };
const _hoisted_4$8 = { class: "gt-option-label" };
const _hoisted_5$6 = /* @__PURE__ */ createElementVNode("div", { class: "gt-option-suffix" }, null, -1);
const __default__$e = {
  name: "GOption"
};
const _sfc_main$i = /* @__PURE__ */ Object.assign(__default__$e, {
  props: {
    modelValue: {},
    selected: {
      type: Boolean,
      default: () => false
    },
    label: {
      type: String,
      default: () => null
    },
    value: {
      default: () => null
    },
    index: {
      type: Number,
      default: () => 0
    }
  },
  emits: [
    "update:modelValue",
    "update:selected",
    "toggleOption"
  ],
  setup(__props, { emit: emits }) {
    const props = __props;
    const { selected, label, value, index: index2 } = toRefs(props);
    const handleClick = () => {
      emits("update:selected", !selected.value, index2.value, {
        label: label.value,
        value: value.value,
        index: index2.value
      });
      emits("update:modelValue", !selected.value);
      emits("toggleOption");
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-option-wrapper", { selected: unref(selected) }])
      }, [
        createElementVNode("div", {
          class: "gt-option-content-wrapper",
          onClick: withModifiers(handleClick, ["stop"])
        }, [
          createElementVNode("div", _hoisted_2$b, [
            createElementVNode("div", _hoisted_3$9, [
              createVNode(_component_g_icon, {
                style: {
                  display: "grid",
                  "align-content": "center",
                  width: "24px",
                  height: "24px"
                },
                name: "check"
              })
            ]),
            createElementVNode("div", _hoisted_4$8, [
              createElementVNode("p", null, toDisplayString(unref(label)), 1)
            ]),
            _hoisted_5$6
          ])
        ], 8, _hoisted_1$e)
      ], 2);
    };
  }
});
_sfc_main$i.install = function(Vue) {
  Vue.component(_sfc_main$i.name, _sfc_main$i);
};
const _hoisted_1$d = { class: "gt-pagination" };
const _hoisted_2$a = { class: "gt-flex" };
const _hoisted_3$8 = { class: "pageNums" };
const _hoisted_4$7 = ["onClick"];
const _hoisted_5$5 = { key: 0 };
const __default__$d = {
  name: "GPagination"
};
const _sfc_main$h = /* @__PURE__ */ Object.assign(__default__$d, {
  props: {
    pageInfo: {
      type: Object,
      default: {
        currentPage: 13,
        total: 200,
        perPageNums: 15
      }
    },
    gap: {
      type: Number,
      default: 5
    },
    underline: {
      type: Boolean,
      default: false
    }
  },
  emits: ["updatePage"],
  setup(__props, { emit }) {
    const props = __props;
    const current = ref(props.pageInfo.currentPage || 1);
    const firstPage = 1;
    const lastPage = Math.ceil(props.pageInfo.total / props.pageInfo.perPageNums);
    watch(
      () => current.value,
      (val) => {
        emit("updatePage", val);
      }
    );
    const pagesComputed = computed(() => {
      let headAndTail = false;
      let middle = false;
      if (current.value <= firstPage + 2 || current.value > lastPage - 3) {
        headAndTail = true;
      }
      headAndTail = {
        head: lastPage > 7 ? [firstPage, "pre-dot"] : [firstPage],
        tail: lastPage > 7 ? ["next-dot", lastPage] : [lastPage]
      };
      if (current.value <= firstPage + 3) {
        headAndTail.head = [firstPage];
        middle = [
          firstPage + 1,
          firstPage + 2,
          firstPage + 3,
          firstPage + 4,
          firstPage + 5
        ];
      }
      if (current.value >= lastPage - 3) {
        headAndTail.tail = [lastPage];
        middle = [
          lastPage - 5,
          lastPage - 4,
          lastPage - 3,
          lastPage - 2,
          lastPage - 1
        ];
      }
      if (!middle) {
        middle = [
          current.value - 2,
          current.value - 1,
          current.value,
          current.value + 1,
          current.value + 2
        ];
      }
      middle = middle.filter((val) => val > firstPage && val < lastPage);
      let arr = [
        ...headAndTail.head,
        ...middle,
        ...headAndTail.tail
      ];
      return arr;
    });
    const handlePrePage = () => {
      if (current.value != firstPage) {
        current.value = current.value - 1;
      }
    };
    const handleNextPage = () => {
      if (current.value != lastPage) {
        current.value = current.value + 1;
      }
    };
    const handlePageChange = (num) => {
      switch (num) {
        case "pre-dot": {
          current.value = current.value - props.gap;
          break;
        }
        case "next-dot": {
          current.value = current.value + props.gap;
          break;
        }
        default: {
          current.value = num;
        }
      }
    };
    const getClass = (num) => {
      if (current.value == num && props.underline)
        return "underline-text";
      if (current.value == num)
        return "current";
      if (num == "pre-dot" || num == "next-dot")
        return num;
      return "";
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        createElementVNode("div", _hoisted_2$a, [
          createElementVNode("div", {
            class: normalizeClass(["pre-next pre", current.value == firstPage ? "disable" : ""]),
            onClick: handlePrePage
          }, [
            createVNode(_component_g_icon, { name: "chevron-left" }),
            createTextVNode("\u4E0A\u4E00\u9801 ")
          ], 2),
          createElementVNode("div", _hoisted_3$8, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagesComputed), (num) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(["num", getClass(num)]),
                key: "n" + num,
                onClick: () => {
                  handlePageChange(num);
                }
              }, [
                num != "pre-dot" && num != "next-dot" ? (openBlock(), createElementBlock("span", _hoisted_5$5, toDisplayString(num), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  __props.pageInfo.total ? (openBlock(), createBlock(_component_g_icon, {
                    key: 0,
                    name: "ellipsis",
                    size: "md"
                  })) : createCommentVNode("", true)
                ], 64))
              ], 10, _hoisted_4$7);
            }), 128))
          ]),
          createElementVNode("div", {
            class: normalizeClass(["pre-next next", current.value == unref(lastPage) ? "disable" : ""]),
            onClick: handleNextPage
          }, [
            createTextVNode(" \u4E0B\u4E00\u9801"),
            createVNode(_component_g_icon, { name: "chevron-right" })
          ], 2)
        ])
      ]);
    };
  }
});
_sfc_main$h.install = function(Vue) {
  Vue.component(_sfc_main$h.name, _sfc_main$h);
};
const _hoisted_1$c = ["onClick"];
const _hoisted_2$9 = {
  fill: "none",
  height: "20",
  viewBox: "0 0 20 20",
  width: "20",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_3$7 = ["fill"];
const _hoisted_4$6 = ["fill"];
const _hoisted_5$4 = {
  d: "M18 10C18 14.4183 14.4183 18 10 18C5.58172 18 2 14.4183 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10ZM4.75173 10C4.75173 12.8985 7.10146 15.2483 10 15.2483C12.8985 15.2483 15.2483 12.8985 15.2483 10C15.2483 7.10146 12.8985 4.75173 10 4.75173C7.10146 4.75173 4.75173 7.10146 4.75173 10Z",
  fill: "white"
};
const _hoisted_6$3 = ["stroke"];
const _hoisted_7$2 = {
  key: 1,
  class: "radiobox-error-msg"
};
const __default__$c = {
  name: "GRadiobox"
};
const _sfc_main$g = /* @__PURE__ */ Object.assign(__default__$c, {
  props: {
    name: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: Boolean,
      default: false
    },
    label: {
      default: null
    },
    value: {
      default: null
    },
    parentValue: {
      default: null
    },
    formParentValue: {
      default: null
    },
    handleChildClick: {
      default: null
    },
    validResult: {
      default: {}
    },
    handleValChange: {
      type: Function
    },
    handleRulesValid: {
      type: Function
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const {
      name,
      disabled,
      modelValue,
      value,
      parentValue,
      formParentValue,
      handleChildClick,
      validResult,
      handleValChange,
      handleRulesValid
    } = __props;
    const errorMsg = computed(() => {
      var _a2;
      return (_a2 = validResult[name]) == null ? void 0 : _a2.message;
    });
    const isChecked = isBoolean(formParentValue) ? ref(formParentValue) : parentValue ? computed(() => {
      return value === parentValue.value;
    }) : ref(modelValue);
    const onClick = () => {
      if (!disabled && handleChildClick && value) {
        handleChildClick(value);
      }
      if (!disabled && !handleChildClick) {
        let val = !isChecked.value;
        isChecked.value = val;
        emit("update:modelValue", val);
        if (handleValChange) {
          console.log(val, name);
          handleValChange(val, name);
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([__props.disabled ? "disabled" : "", "gt-radiobox"]),
        onClick: withModifiers(onClick, ["prevent"])
      }, [
        (openBlock(), createElementBlock("svg", _hoisted_2$9, [
          createElementVNode("rect", {
            fill: __props.disabled ? unref(isChecked) ? "#AAAAAA" : "" : unref(isChecked) ? "#32A03D" : "#EEF5EB",
            height: "19",
            rx: "9.5",
            width: "19",
            x: "0.5",
            y: "0.5"
          }, null, 8, _hoisted_3$7),
          createElementVNode("circle", {
            class: normalizeClass(unref(isChecked) ? "circle show" : "circle"),
            fill: __props.disabled ? unref(isChecked) ? "#AAAAAA" : "" : unref(isChecked) ? "#32A03D" : "#EEF5EB",
            cx: "10",
            cy: "10",
            r: "5.25"
          }, null, 10, _hoisted_4$6),
          withDirectives(createElementVNode("path", _hoisted_5$4, null, 512), [
            [vShow, unref(isChecked)]
          ]),
          createElementVNode("rect", {
            stroke: __props.disabled ? "#AAA" : "#32A03D",
            height: "19",
            rx: "9.5",
            width: "19",
            x: "0.5",
            y: "0.5"
          }, null, 8, _hoisted_6$3)
        ])),
        __props.label ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass([__props.disabled ? "label-disabled" : "", "label"])
        }, toDisplayString(__props.label), 3)) : createCommentVNode("", true),
        unref(errorMsg) ? (openBlock(), createElementBlock("span", _hoisted_7$2, toDisplayString(unref(errorMsg)), 1)) : createCommentVNode("", true)
      ], 10, _hoisted_1$c);
    };
  }
});
const _sfc_main$f = {
  name: "GRadioboxGroup",
  props: ["modelValue"],
  emits: ["update:modelValue"],
  setup(props, { slots, emit }) {
    const validChilds = slots.default() ? slots.default().filter((item) => item.type.name === "GRadiobox").map((item) => {
      return {
        ...item,
        props: {
          ...item.props,
          parentValue: computed(() => props.modelValue),
          handleChildClick: (val) => emit("update:modelValue", val)
        }
      };
    }) : [];
    return () => h("div", validChilds);
  }
};
_sfc_main$g.install = function(Vue) {
  Vue.component(_sfc_main$g.name, _sfc_main$g);
};
_sfc_main$f.install = function(Vue) {
  Vue.component(_sfc_main$f.name, _sfc_main$f);
};
var Radiobox = { GRadiobox: _sfc_main$g, GRadioboxGroup: _sfc_main$f };
const _hoisted_1$b = { class: "gt-select-wrapper" };
const _hoisted_2$8 = ["onClick"];
const _hoisted_3$6 = { class: "gt-select-content" };
const _hoisted_4$5 = { class: "gt-select-prefix" };
const _hoisted_5$3 = ["placeholder", "value"];
const _hoisted_6$2 = { class: "gt-select-suffix" };
const __default__$b = {
  name: "GSelect"
};
const _sfc_main$e = /* @__PURE__ */ Object.assign(__default__$b, {
  props: {
    modelValue: {},
    multiple: {
      type: Boolean,
      default: () => {
        return false;
      }
    },
    placeholder: {
      type: String,
      default: () => null
    },
    bindResult: {
      type: String,
      default: () => "index"
    }
  },
  emits: ["update:modelValue", "change"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const slots = ref(useSlots());
    const { modelValue, multiple, bindResult } = toRefs(props);
    const optionList = ref([]);
    const showOption = ref(false);
    const toggleOption = () => {
      showOption.value = !showOption.value;
    };
    watch(
      () => {
        return showOption.value;
      },
      (val) => {
        if (val) {
          document.body.addEventListener("click", toggleOption);
        } else {
          document.body.removeEventListener("click", toggleOption);
        }
      }
    );
    const updateModelValue = (result, idx, option) => {
      let resultModelValue = modelValue.value;
      if (multiple.value) {
        resultModelValue = resultModelValue != null ? resultModelValue : [];
        if (result === false) {
          resultModelValue.splice(
            resultModelValue.indexOf(option[bindResult.value]),
            1
          );
        } else {
          resultModelValue.push(option[bindResult.value]);
        }
      } else {
        resultModelValue = option[bindResult.value];
      }
      handleChange(resultModelValue);
      emits("update:modelValue", resultModelValue);
    };
    const list = computed(() => {
      let options = [];
      let result = [];
      if (typeof slots.value.default === "function") {
        result = findAllOption(slots.value.default()).map((child, idx) => {
          var _a2;
          let option = {
            index: idx,
            label: child.props.label,
            value: child.props.value
          };
          options.push(option);
          let selected = false;
          if (multiple.value) {
            selected = ((_a2 = modelValue.value) == null ? void 0 : _a2.indexOf(option[bindResult.value])) > -1;
          } else {
            selected = modelValue.value === option[bindResult.value];
          }
          let result2 = {
            ...child,
            props: {
              ...child.props,
              index: idx,
              selected,
              onToggleOption: multiple.value ? () => {
              } : toggleOption,
              "onUpdate:selected": updateModelValue
            }
          };
          return result2;
        });
      }
      optionList.value = options;
      return result;
    });
    const findAllOption = (slots2) => {
      var _a2;
      let result = [];
      for (let i = 0; i < slots2.length; i++) {
        if (((_a2 = slots2[i].children) == null ? void 0 : _a2.length) !== 0 && slots2[i].children instanceof Array) {
          result.push(...findAllOption(slots2[i].children));
        } else if (slots2[i].type instanceof Object && slots2[i].type.name === "GOption") {
          result.push(slots2[i]);
        }
      }
      return result;
    };
    const optionsRender = computed(() => {
      return h("div", { class: "gt-select-option" }, list.value);
    });
    const inputValue = computed(() => {
      var _a2, _b, _c, _d;
      let result = "";
      if (multiple.value) {
        result = ((_b = (_a2 = optionList.value) == null ? void 0 : _a2.filter((record) => {
          var _a3;
          if (((_a3 = modelValue.value) == null ? void 0 : _a3.indexOf(record[bindResult.value])) > -1) {
            return true;
          }
          return false;
        })) != null ? _b : []).map((record) => {
          return record.label;
        });
        return result.join(", ");
      } else {
        result = (_c = optionList.value) == null ? void 0 : _c.filter((record) => {
          return record[bindResult.value] === modelValue.value;
        });
        return (_d = result[0]) == null ? void 0 : _d.label;
      }
    });
    const handleChange = (model) => {
      emits("change", model);
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$b, [
        createElementVNode("div", {
          class: "gt-select-content-wrapper",
          onClick: withModifiers(toggleOption, ["stop"])
        }, [
          createElementVNode("div", _hoisted_3$6, [
            createElementVNode("div", _hoisted_4$5, [
              renderSlot(_ctx.$slots, "prefix")
            ]),
            createElementVNode("input", {
              placeholder: __props.placeholder,
              value: unref(inputValue),
              class: "gt-select-input",
              readonly: true
            }, null, 8, _hoisted_5$3),
            createElementVNode("div", _hoisted_6$2, [
              createVNode(_component_g_icon, {
                class: "gt-icon-rotate-90",
                style: { "display": "contents", "width": "24px", "height": "24px", "color": "#55585e" },
                name: "right"
              })
            ])
          ])
        ], 8, _hoisted_2$8),
        withDirectives(createElementVNode("div", {
          class: normalizeClass(["gt-select-option-wrapper", { "tp-aniIn": showOption.value, "tp-aniOut": !showOption.value }])
        }, [
          createVNode(unref(optionsRender))
        ], 2), [
          [vShow, showOption.value]
        ])
      ]);
    };
  }
});
_sfc_main$e.install = function(Vue) {
  Vue.component(_sfc_main$e.name, _sfc_main$e);
};
const _hoisted_1$a = { class: "gt-sort-label-wrapper" };
const _hoisted_2$7 = { if: "labelName" };
const __default__$a = {
  name: "GSortLabel"
};
const _sfc_main$d = /* @__PURE__ */ Object.assign(__default__$a, {
  props: {
    modelValue: {},
    options: {
      type: Array,
      default: []
    },
    labelName: {
      type: String
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emits }) {
    var _a2;
    const { modelValue, options, labelName } = __props;
    let index2 = options.findIndex((item) => item.value == modelValue);
    const curIndex = ref(index2);
    const currentOptionLabel = ref(((_a2 = options[index2]) == null ? void 0 : _a2.label) || null);
    const isClicked = ref(false);
    watch(
      () => curIndex.value,
      (cur, old) => {
        var _a3;
        currentOptionLabel.value = ((_a3 = options[cur]) == null ? void 0 : _a3.label) || null;
      }
    );
    const handleLabelChange = () => {
      if (curIndex.value == null)
        return false;
      isClicked.value = true;
      let newIndex = options[curIndex.value + 1] ? curIndex.value + 1 : 0;
      let val = options[newIndex].value;
      emits("update:modelValue", val);
      curIndex.value = newIndex;
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        createElementVNode("span", _hoisted_2$7, toDisplayString(__props.labelName), 1),
        createElementVNode("div", {
          class: normalizeClass(["gt-sort-label", isClicked.value ? "clicked" : ""]),
          onClick: handleLabelChange
        }, [
          createTextVNode(toDisplayString(currentOptionLabel.value ? currentOptionLabel.value : "N/A") + " ", 1),
          createVNode(_component_g_icon, {
            class: "icon",
            name: "sequence",
            size: "md"
          })
        ], 2)
      ]);
    };
  }
});
_sfc_main$d.install = function(Vue) {
  Vue.component(_sfc_main$d.name, _sfc_main$d);
};
const _hoisted_1$9 = ["onClick"];
const _hoisted_2$6 = { class: "gt-relative" };
const _hoisted_3$5 = ["checked"];
const _hoisted_4$4 = { class: "label-text" };
const __default__$9 = {
  name: "GSwitch"
};
const _sfc_main$c = /* @__PURE__ */ Object.assign(__default__$9, {
  props: {
    modelValue: {
      default: false
    },
    statusLabel: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const { modelValue, statusLabel } = __props;
    const isChecked = ref(modelValue);
    const onClick = () => {
      let val = !isChecked.value;
      isChecked.value = val;
      emit("update:modelValue", val);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        onClick: withModifiers(onClick, ["prevent"]),
        class: "gt-switch-input"
      }, [
        createElementVNode("div", _hoisted_2$6, [
          createElementVNode("input", {
            checked: __props.modelValue,
            type: "checkbox"
          }, null, 8, _hoisted_3$5),
          createElementVNode("div", {
            class: normalizeClass([__props.modelValue ? "bg-open" : "bg-close", "bar"])
          }, null, 2),
          createElementVNode("div", {
            class: normalizeClass([__props.modelValue ? "checked" : "", "dot"])
          }, null, 2)
        ]),
        createElementVNode("div", _hoisted_4$4, toDisplayString(__props.statusLabel ? __props.modelValue ? "\u958B\u555F" : "\u95DC\u9589" : ""), 1)
      ], 8, _hoisted_1$9);
    };
  }
});
_sfc_main$c.install = function(Vue) {
  Vue.component(_sfc_main$c.name, _sfc_main$c);
};
const _hoisted_1$8 = ["id"];
const _hoisted_2$5 = { class: "table-head" };
const _hoisted_3$4 = {
  key: 0,
  class: "head-column checknoxColumn"
};
const _hoisted_4$3 = ["onClick"];
const _hoisted_5$2 = {
  key: 0,
  class: "head-column checknoxColumn"
};
const _hoisted_6$1 = {
  key: 0,
  class: "loading"
};
const _hoisted_7$1 = {
  key: 1,
  class: "table-rows"
};
const _hoisted_8$1 = ["onClick"];
const _hoisted_9$1 = ["onClick"];
const _hoisted_10$1 = ["onClick"];
const _hoisted_11$1 = { key: 2 };
const __default__$8 = {
  name: "GTable"
};
const _sfc_main$b = /* @__PURE__ */ Object.assign(__default__$8, {
  props: {
    name: {},
    columns: {
      type: Array,
      default: []
    },
    data: {
      type: Array,
      default: []
    },
    isCheckbox: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: null
    },
    height: {
      type: Number
    },
    rowClick: {
      type: Boolean,
      default: false
    },
    isLoading: {
      type: Boolean,
      default: false
    },
    underline: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:data"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const tableEnum = {
      CHECKBOX: "checkbox",
      ASC: "asc",
      DESC: "desc"
    };
    const gtTableId = v4();
    const gtTableWidth = ref(0);
    const slots = useSlots();
    const slotColumns = Object.keys(slots);
    const isCheckAll = ref(false);
    const columnSortStatus = reactive({});
    const isOverflowX = ref(false);
    const isOverflowY = ref(false);
    const isHover = ref(false);
    const columnsComputed = computed(() => {
      let arr = props.columns.map((cItem, cIdx) => {
        let width = "";
        if (typeof cItem.width === "number") {
          width = cItem.width + "px";
        } else if (typeof cItem.width === "string") {
          width = cItem.width;
        } else {
          width = "80px";
        }
        return cItem.name ? {
          ...cItem,
          name: cItem.name,
          label: cItem.label || "",
          width,
          sort: cItem.sort || false
        } : false;
      }).filter((cItem) => cItem);
      return arr;
    });
    const columnsClassComputed = (cItem) => {
      let arr = ["with-flex-grow"];
      if (cItem.sort || cItem.handleSortCallback)
        arr.push("gt-cursor-pointer");
      return arr;
    };
    const wrapperComputed = computed(() => {
      let arr = [];
      if (props.isLoading || !isHover.value) {
        return ["overflow-with-hidden"];
      }
      if (isOverflowX.value && isHover.value) {
        return ["overflow-with-x-scroll"];
      }
      return arr;
    });
    const dataWithStatus = ref([
      ...props.data.map((dItem) => {
        return {
          ...dItem,
          gtTableRowChecked: false
        };
      })
    ]);
    const checkWidthHeight = () => {
      var _a2, _b;
      gtTableWidth.value = ((_a2 = document.getElementById(`gt-${gtTableId}`)) == null ? void 0 : _a2.offsetWidth) || 0;
      if (gtTableWidth.value && tableWidthComputed.value) {
        isOverflowX.value = gtTableWidth.value && tableWidthComputed.value > gtTableWidth.value ? true : false;
      }
      let rowsHeight = ((_b = document.querySelector(`#gt-${gtTableId} .table-rows`)) == null ? void 0 : _b.offsetHeight) || 0;
      let height = parseInt(props.height) - 40;
      if (rowsHeight && height) {
        isOverflowY.value = rowsHeight > height ? true : false;
      }
    };
    watch(
      () => props.data,
      (val) => {
        dataWithStatus.value = [
          ...props.data.map((dItem) => {
            return {
              ...dItem,
              gtTableRowChecked: false
            };
          })
        ];
        isCheckAll.value = false;
        nextTick(() => {
          checkWidthHeight();
        });
      }
    );
    watch(
      () => isCheckAll.value,
      () => {
        dataWithStatus.value = dataWithStatus.value.map((dItem) => {
          return {
            ...dItem,
            gtTableRowChecked: isCheckAll.value
          };
        });
      }
    );
    const tableWidthComputed = computed(() => {
      let width = columnsComputed.value.map((item) => parseInt(("" + item.width).replace("px", ""))).reduce((a, b) => a + b, 0) + 80;
      return width;
    });
    const tableInnerStyleComputed = computed(() => {
      let height = parseInt(props.height) - 40;
      return isOverflowY.value ? {
        height: height ? height + "px" : "none",
        "overflow-y": "scroll"
      } : {
        height: height ? height + "px" : "none"
      };
    });
    const selectionIcon = computed(() => {
      var _a2, _b, _c;
      let len = dataWithStatus.value.map((dataItem) => dataItem.gtTableRowChecked).filter((bool) => bool).length;
      if (len === 0 || ((_a2 = dataWithStatus.value) == null ? void 0 : _a2.length) === 0) {
        return null;
      } else if (len !== ((_b = dataWithStatus.value) == null ? void 0 : _b.length)) {
        return "minus";
      } else if (len === ((_c = dataWithStatus.value) == null ? void 0 : _c.length)) {
        return "plus";
      }
    });
    const selectionClick = function() {
      switch (selectionIcon.value) {
        case null:
        case "minus":
          dataWithStatus.value = dataWithStatus.value.map((item) => {
            return {
              ...item,
              gtTableRowChecked: true
            };
          });
          break;
        case "plus":
          dataWithStatus.value = dataWithStatus.value.map((item) => {
            return {
              ...item,
              gtTableRowChecked: false
            };
          });
          break;
      }
    };
    const handleColumnSort = (cItem) => {
      if (cItem.handleSortCallback) {
        cItem.handleSortCallback();
      }
      if (cItem.sort) {
        let target = cItem.name;
        if (columnSortStatus[target] === tableEnum.ASC || !columnSortStatus[target]) {
          dataWithStatus.value.sort((a, b) => {
            return b[target] - a[target];
          });
          columnSortStatus[target] = tableEnum.DESC;
        } else {
          dataWithStatus.value.sort((a, b) => {
            return a[target] - b[target];
          });
          columnSortStatus[target] = tableEnum.ASC;
        }
      }
    };
    const handleRowClick = (row) => {
      if (!props.rowClick)
        return false;
      row.gtTableRowChecked = !row.gtTableRowChecked;
    };
    const getCheckedList = () => {
      return dataWithStatus.value.filter((dItem) => dItem.gtTableRowChecked).map((dItem) => {
        let obj = { ...dItem };
        delete obj.gtTableRowChecked;
        return obj;
      });
    };
    expose({
      getCheckedList
    });
    onMounted(() => {
      checkWidthHeight();
    });
    return (_ctx, _cache) => {
      const _component_g_checkbox = resolveComponent("g-checkbox");
      const _component_g_icon = resolveComponent("g-icon");
      const _component_g_loading_icon = resolveComponent("g-loading-icon");
      return openBlock(), createElementBlock("div", {
        id: "gt-" + unref(gtTableId),
        ref: "gtTable",
        class: "gt-table-wrapper",
        style: normalizeStyle(__props.width ? { width: __props.width + "px" } : {})
      }, [
        createElementVNode("div", {
          class: normalizeClass(unref(wrapperComputed)),
          style: normalizeStyle({ height: `${__props.height}px` }),
          onMousemove: _cache[0] || (_cache[0] = ($event) => isHover.value = true),
          onMouseleave: _cache[1] || (_cache[1] = ($event) => isHover.value = false)
        }, [
          createElementVNode("div", {
            class: "gt-table",
            style: normalizeStyle({ width: unref(tableWidthComputed) + "px" })
          }, [
            createElementVNode("div", _hoisted_2$5, [
              __props.isCheckbox ? (openBlock(), createElementBlock("div", _hoisted_3$4, [
                createVNode(_component_g_checkbox, {
                  type: "white",
                  checkedIcon: unref(selectionIcon),
                  onChange: selectionClick
                }, null, 8, ["checkedIcon"])
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columnsComputed), (cItem, columnIdx) => {
                var _a2, _b;
                return openBlock(), createElementBlock("div", {
                  key: cItem.name || cItem.type,
                  style: normalizeStyle({ width: cItem.width }),
                  class: normalizeClass(["head-column", columnsClassComputed(cItem)]),
                  onClick: () => handleColumnSort(cItem)
                }, [
                  cItem.type === "selection" ? (openBlock(), createElementBlock("div", _hoisted_5$2, [
                    createVNode(_component_g_checkbox, {
                      controlMode: true,
                      type: "white",
                      checkedIcon: unref(selectionIcon),
                      onChange: selectionClick
                    }, null, 8, ["checkedIcon"])
                  ])) : ((_a2 = cItem.scopedSlots) == null ? void 0 : _a2.customHeaderRender) ? renderSlot(_ctx.$slots, (_b = cItem.scopedSlots) == null ? void 0 : _b.customHeaderRender, normalizeProps(mergeProps({ key: 1 }, { column: cItem, $index: columnIdx }))) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createElementVNode("span", null, toDisplayString(cItem.label), 1),
                    cItem.sort || typeof cItem.handleSortCallback === "function" ? (openBlock(), createBlock(_component_g_icon, {
                      key: 0,
                      class: "sort-icon",
                      name: "sequence"
                    })) : createCommentVNode("", true)
                  ], 64))
                ], 14, _hoisted_4$3);
              }), 128))
            ]),
            createElementVNode("div", {
              class: normalizeClass(["table-body", __props.isLoading ? "overflow-with-hidden" : ""]),
              style: normalizeStyle(unref(tableInnerStyleComputed))
            }, [
              __props.isLoading ? (openBlock(), createElementBlock("div", _hoisted_6$1, [
                createVNode(_component_g_loading_icon)
              ])) : (openBlock(), createElementBlock("div", _hoisted_7$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(dataWithStatus.value, (rItem, rIdx) => {
                  return openBlock(), createElementBlock("div", {
                    class: normalizeClass(["row", rItem.gtTableRowChecked ? "row-check" : __props.underline ? "underline" : ""]),
                    key: rIdx,
                    onClick: () => {
                      handleRowClick(rItem);
                    }
                  }, [
                    __props.isCheckbox ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: "row-cell checknoxColumn",
                      onClick: () => {
                        handleRowClick(rItem);
                      }
                    }, [
                      createVNode(_component_g_checkbox, {
                        modelValue: rItem.gtTableRowChecked,
                        "onUpdate:modelValue": ($event) => rItem.gtTableRowChecked = $event,
                        type: "white"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ], 8, _hoisted_9$1)) : createCommentVNode("", true),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columnsComputed), (cItem, cIdx) => {
                      return openBlock(), createElementBlock("div", {
                        key: cItem.name + "-" + rIdx + "-" + cIdx,
                        style: normalizeStyle({ width: cItem.width }),
                        class: "row-cell with-flex-grow"
                      }, [
                        unref(slotColumns).includes(cItem.name) ? renderSlot(_ctx.$slots, cItem.name, {
                          key: 0,
                          row: rItem
                        }) : cItem.type === "selection" ? (openBlock(), createElementBlock("div", {
                          key: 1,
                          class: "row-cell checknoxColumn",
                          onClick: () => {
                            handleRowClick(rItem);
                          }
                        }, [
                          createVNode(_component_g_checkbox, {
                            modelValue: rItem.gtTableRowChecked,
                            "onUpdate:modelValue": ($event) => rItem.gtTableRowChecked = $event,
                            type: "white"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ], 8, _hoisted_10$1)) : (openBlock(), createElementBlock("span", _hoisted_11$1, toDisplayString(rItem[cItem.name] || cItem.name), 1))
                      ], 4);
                    }), 128))
                  ], 10, _hoisted_8$1);
                }), 128))
              ]))
            ], 6)
          ], 4)
        ], 38)
      ], 12, _hoisted_1$8);
    };
  }
});
_sfc_main$b.install = function(Vue) {
  Vue.component(_sfc_main$b.name, _sfc_main$b);
};
const _sfc_main$a = {
  name: "GTableColumn"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return null;
}
var GTableColumn = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render]]);
GTableColumn.install = function(Vue) {
  Vue.component(GTableColumn.name, GTableColumn);
};
const _hoisted_1$7 = { class: "table-head" };
const _hoisted_2$4 = ["onClick"];
const _hoisted_3$3 = { class: "row-content" };
const _hoisted_4$2 = { key: 2 };
const __default__$7 = {
  name: "GTable2"
};
const _sfc_main$9 = /* @__PURE__ */ Object.assign(__default__$7, {
  props: {
    columns: {
      type: Array,
      default: []
    },
    data: {
      type: Array,
      default: []
    },
    width: {
      type: Number,
      default: null
    },
    height: {
      type: Number
    },
    isLoading: {
      type: Boolean,
      default: false
    },
    underline: {
      type: Boolean,
      default: false
    },
    defaultSort: {
      type: Object,
      default: () => {
        return null;
      }
    }
  },
  emits: ["sort-change", "selection-change"],
  setup(__props, { emit }) {
    const props = __props;
    const order = ["ascending", "descending", null];
    const { data, columns, defaultSort } = toRefs(props);
    const gtTableWidth = ref(0);
    useSlots();
    const columnSort = ref(defaultSort.value);
    const isOverflowX = ref(false);
    const selectedList = ref({});
    const selectionIcon = computed(() => {
      var _a2, _b, _c;
      let len = Object.values(selectedList.value).filter((bool) => bool).length;
      if (len === 0 || ((_a2 = data.value) == null ? void 0 : _a2.length) === 0) {
        return null;
      } else if (len !== ((_b = data.value) == null ? void 0 : _b.length)) {
        return "minus";
      } else if (len === ((_c = data.value) == null ? void 0 : _c.length)) {
        return "plus";
      }
    });
    const selectionClick = function() {
      let len = Object.values(selectedList.value).length;
      let result = {};
      switch (selectionIcon.value) {
        case null:
        case "minus":
          for (let i = 0; i < len; i++) {
            result[String(i)] = true;
          }
          break;
        case "plus":
          for (let i = 0; i < len; i++) {
            result[String(i)] = false;
          }
          break;
      }
      selectedList.value = result;
    };
    watch(
      () => data,
      () => {
        var _a2;
        (_a2 = data.value) == null ? void 0 : _a2.forEach((record, idx) => {
          selectedList.value[String(idx)] = false;
        });
      },
      { deep: true, immediate: true }
    );
    watch(
      () => selectedList,
      () => {
        let selected = data.value.filter((record, idx) => {
          return selectedList.value[String(idx)];
        });
        emit("selection-change", selected);
      },
      { deep: true }
    );
    const columnsComputed = computed(() => {
      let arr = columns.value.map((column, columnIdx) => {
        let style = {};
        if (typeof column.width === "number") {
          style.width = column.width + "px";
          style["min-width"] = column.width + "px";
          style["max-width"] = column.width + "px";
        } else if (typeof column.width === "string") {
          style.width = column.width;
          style["min-width"] = column.width;
          style["max-width"] = column.width;
        } else {
          style.width = "auto";
        }
        let label = column.label;
        if (typeof label === "function") {
          label = label();
        } else {
          label = label != null ? label : "";
        }
        let sortable = column.sortable;
        if (typeof sortable === "string" && sortable === "custom") {
          sortable = {
            icon: "sequence",
            click: (column2) => handleRemoteColumnSort(column2)
          };
        } else if (typeof sortable === "boolean") {
          sortable = {
            icon: "sequence",
            click: handleLocalColumnSort
          };
        }
        return {
          type: column.type,
          prop: column.prop,
          sortable,
          scopedSlots: column.scopedSlots,
          label,
          style
        };
      }).filter((cItem) => cItem);
      return arr;
    });
    const dataComputed = computed(() => {
      return data.value;
    });
    const columnsClassComputed = (column) => {
      var _a2;
      let arr = ["with-flex-grow"];
      if (column.type === "selection")
        ;
      if ((_a2 = column.sortable) == null ? void 0 : _a2.click) {
        arr.push("gt-cursor-pointer");
      }
      return arr;
    };
    const wrapperComputed = computed(() => {
      let arr = [];
      if (props.isLoading) {
        return ["overflow-with-hidden"];
      }
      if (isOverflowX.value) {
        return ["overflow-with-x-scroll"];
      }
      return arr;
    });
    const tableWidthComputed = computed(() => {
      let width = columnsComputed.value.map((item) => item.style.width).reduce((a, b) => a + b, 0) + 80;
      return width;
    });
    watch(
      () => gtTableWidth.value,
      (val) => {
      }
    );
    const tableInnerStyleComputed = computed(() => {
      let height = parseInt(props.height) - 40;
      return {
        height: height ? height + "px" : "none"
      };
    });
    const handleLocalColumnSort = (cItem) => {
    };
    const handleRemoteColumnSort = (column) => {
      var _a2, _b;
      let oldProp = (_a2 = columnSort.value) == null ? void 0 : _a2.prop;
      if (column.prop === oldProp) {
        columnSort.value.order = (((_b = columnSort.value.order) != null ? _b : 0) + 1) % 3;
      } else {
        columnSort.value.prop = column.prop;
        columnSort.value.order = 0;
      }
      emit("sort-change", {
        column,
        prop: columnSort.value.prop,
        order: order[columnSort.value.order]
      });
    };
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      var _a2;
      const _component_g_checkbox = resolveComponent("g-checkbox");
      const _component_g_icon = resolveComponent("g-icon");
      const _component_g_loading_icon = resolveComponent("g-loading-icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["gt-table2-wrapper", unref(wrapperComputed)]),
        style: normalizeStyle(__props.width ? { width: __props.width + "px" } : {})
      }, [
        createElementVNode("div", {
          class: "gt-table2",
          style: normalizeStyle({ width: unref(tableWidthComputed) + "px" })
        }, [
          createElementVNode("div", _hoisted_1$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columnsComputed), (column, columnIdx) => {
              var _a3, _b, _c, _d;
              return openBlock(), createElementBlock("div", {
                key: columnIdx,
                style: normalizeStyle(column.style),
                class: normalizeClass(["head-column", columnsClassComputed(column)]),
                onClick: () => {
                  var _a4;
                  (_a4 = column.sortable) == null ? void 0 : _a4.click(column);
                }
              }, [
                column.type === "selection" ? (openBlock(), createBlock(_component_g_checkbox, {
                  key: 0,
                  controlMode: true,
                  type: "white",
                  checkedIcon: unref(selectionIcon),
                  onChange: _cache[0] || (_cache[0] = (val) => {
                    selectionClick();
                  })
                }, null, 8, ["checkedIcon"])) : ((_a3 = column.scopedSlots) == null ? void 0 : _a3.customHeaderRender) ? renderSlot(_ctx.$slots, (_b = column.scopedSlots) == null ? void 0 : _b.customHeaderRender, normalizeProps(mergeProps({ key: 1 }, { column, $index: columnIdx }))) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createElementVNode("span", null, toDisplayString(column.label), 1),
                  ((_c = column.sortable) == null ? void 0 : _c.icon) ? (openBlock(), createBlock(_component_g_icon, {
                    key: 0,
                    class: "sort-icon",
                    name: (_d = column.sortable) == null ? void 0 : _d.icon
                  }, null, 8, ["name"])) : createCommentVNode("", true)
                ], 64))
              ], 14, _hoisted_2$4);
            }), 128))
          ]),
          createElementVNode("div", {
            class: normalizeClass(["table-body", __props.isLoading ? "overflow-with-hidden" : ""]),
            style: normalizeStyle(unref(tableInnerStyleComputed))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(dataComputed), (rowItem, rowIdx) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass(["row", {
                  underline: __props.underline,
                  "row-check": selectedList.value[String(rowIdx)]
                }]),
                key: rowIdx
              }, [
                createElementVNode("div", _hoisted_3$3, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columnsComputed), (column, columnIdx) => {
                    var _a3, _b;
                    return openBlock(), createElementBlock("div", {
                      key: columnIdx,
                      style: normalizeStyle(column.style),
                      class: "row-cell with-flex-grow"
                    }, [
                      ((_a3 = column.scopedSlots) == null ? void 0 : _a3.customRender) ? renderSlot(_ctx.$slots, (_b = column.scopedSlots) == null ? void 0 : _b.customRender, normalizeProps(mergeProps({ key: 0 }, {
                        prop: rowItem[column.prop],
                        row: rowItem,
                        column,
                        $index: rowIdx
                      }))) : column.type === "selection" ? (openBlock(), createBlock(_component_g_checkbox, {
                        key: 1,
                        type: "white",
                        modelValue: selectedList.value[String(rowIdx)],
                        "onUpdate:modelValue": ($event) => selectedList.value[String(rowIdx)] = $event
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])) : (openBlock(), createElementBlock("span", _hoisted_4$2, toDisplayString(rowItem[column.prop] || ""), 1))
                    ], 4);
                  }), 128))
                ])
              ], 2);
            }), 128))
          ], 6),
          __props.isLoading ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "loading",
            style: normalizeStyle(((_a2 = unref(dataComputed)) == null ? void 0 : _a2.length) ? { position: "absolute" } : {})
          }, [
            createVNode(_component_g_loading_icon)
          ], 4)) : createCommentVNode("", true)
        ], 4)
      ], 6);
    };
  }
});
_sfc_main$9.install = function(Vue) {
  Vue.component(_sfc_main$9.name, _sfc_main$9);
};
const _hoisted_1$6 = {
  key: 0,
  class: "circle"
};
const __default__$6 = {
  name: "GTag"
};
const _sfc_main$8 = /* @__PURE__ */ Object.assign(__default__$6, {
  props: {
    label: {
      type: String,
      default: "\u6A19\u7C64"
    },
    type: {
      type: String,
      default: "DEFAULT"
    },
    border: {
      type: Boolean,
      default: false
    },
    dot: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const { label, type, border, dot } = __props;
    const TagTypeEnum = {
      DEFAULT: "green",
      SECOND: "blue",
      DANGER: "red",
      WARNING: "yellow",
      ACTIVITY: "orange"
    };
    const mapClass = () => {
      let className = [TagTypeEnum[type.toUpperCase()]];
      if (border) {
        className.push("is-border");
      }
      if (dot) {
        className.push("dot");
      }
      if (type.toUpperCase() == "ACTIVITY") {
        className = ["full-orange"];
      }
      return className;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([mapClass(), "gt-tag"])
      }, [
        __props.dot ? (openBlock(), createElementBlock("div", _hoisted_1$6)) : createCommentVNode("", true),
        createTextVNode(" " + toDisplayString(__props.label), 1)
      ], 2);
    };
  }
});
_sfc_main$8.install = function(Vue) {
  Vue.component(_sfc_main$8.name, _sfc_main$8);
};
var SECONDS_A_MINUTE = 60;
var SECONDS_A_HOUR = SECONDS_A_MINUTE * 60;
var SECONDS_A_DAY = SECONDS_A_HOUR * 24;
var SECONDS_A_WEEK = SECONDS_A_DAY * 7;
var MILLISECONDS_A_SECOND = 1e3;
var MILLISECONDS_A_MINUTE = SECONDS_A_MINUTE * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_HOUR = SECONDS_A_HOUR * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_DAY = SECONDS_A_DAY * MILLISECONDS_A_SECOND;
var MILLISECONDS_A_WEEK = SECONDS_A_WEEK * MILLISECONDS_A_SECOND;
var MS = "millisecond";
var S = "second";
var MIN = "minute";
var H = "hour";
var D = "day";
var W = "week";
var M = "month";
var Q = "quarter";
var Y = "year";
var DATE = "date";
var FORMAT_DEFAULT = "YYYY-MM-DDTHH:mm:ssZ";
var INVALID_DATE_STRING = "Invalid Date";
var REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
var en = {
  name: "en",
  weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
  months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
};
var padStart = function padStart2(string, length, pad) {
  var s = String(string);
  if (!s || s.length >= length)
    return string;
  return "" + Array(length + 1 - s.length).join(pad) + string;
};
var padZoneStr = function padZoneStr2(instance) {
  var negMinutes = -instance.utcOffset();
  var minutes = Math.abs(negMinutes);
  var hourOffset = Math.floor(minutes / 60);
  var minuteOffset = minutes % 60;
  return (negMinutes <= 0 ? "+" : "-") + padStart(hourOffset, 2, "0") + ":" + padStart(minuteOffset, 2, "0");
};
var monthDiff = function monthDiff2(a, b) {
  if (a.date() < b.date())
    return -monthDiff2(b, a);
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month());
  var anchor = a.clone().add(wholeMonthDiff, M);
  var c = b - anchor < 0;
  var anchor2 = a.clone().add(wholeMonthDiff + (c ? -1 : 1), M);
  return +(-(wholeMonthDiff + (b - anchor) / (c ? anchor - anchor2 : anchor2 - anchor)) || 0);
};
var absFloor = function absFloor2(n) {
  return n < 0 ? Math.ceil(n) || 0 : Math.floor(n);
};
var prettyUnit = function prettyUnit2(u) {
  var special = {
    M,
    y: Y,
    w: W,
    d: D,
    D: DATE,
    h: H,
    m: MIN,
    s: S,
    ms: MS,
    Q
  };
  return special[u] || String(u || "").toLowerCase().replace(/s$/, "");
};
var isUndefined = function isUndefined2(s) {
  return s === void 0;
};
var U = {
  s: padStart,
  z: padZoneStr,
  m: monthDiff,
  a: absFloor,
  p: prettyUnit,
  u: isUndefined
};
var L = "en";
var Ls = {};
Ls[L] = en;
var isDayjs = function isDayjs2(d) {
  return d instanceof Dayjs;
};
var parseLocale = function parseLocale2(preset, object, isLocal) {
  var l;
  if (!preset)
    return L;
  if (typeof preset === "string") {
    var presetLower = preset.toLowerCase();
    if (Ls[presetLower]) {
      l = presetLower;
    }
    if (object) {
      Ls[presetLower] = object;
      l = presetLower;
    }
    var presetSplit = preset.split("-");
    if (!l && presetSplit.length > 1) {
      return parseLocale2(presetSplit[0]);
    }
  } else {
    var name = preset.name;
    Ls[name] = preset;
    l = name;
  }
  if (!isLocal && l)
    L = l;
  return l || !isLocal && L;
};
var dayjs = function dayjs2(date, c) {
  if (isDayjs(date)) {
    return date.clone();
  }
  var cfg = typeof c === "object" ? c : {};
  cfg.date = date;
  cfg.args = arguments;
  return new Dayjs(cfg);
};
var wrapper = function wrapper2(date, instance) {
  return dayjs(date, {
    locale: instance.$L,
    utc: instance.$u,
    x: instance.$x,
    $offset: instance.$offset
  });
};
var Utils = U;
Utils.l = parseLocale;
Utils.i = isDayjs;
Utils.w = wrapper;
var parseDate = function parseDate2(cfg) {
  var date = cfg.date, utc = cfg.utc;
  if (date === null)
    return new Date(NaN);
  if (Utils.u(date))
    return new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    var d = date.match(REGEX_PARSE);
    if (d) {
      var m = d[2] - 1 || 0;
      var ms = (d[7] || "0").substring(0, 3);
      if (utc) {
        return new Date(Date.UTC(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms));
      }
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
};
var Dayjs = /* @__PURE__ */ function() {
  function Dayjs2(cfg) {
    this.$L = parseLocale(cfg.locale, null, true);
    this.parse(cfg);
  }
  var _proto = Dayjs2.prototype;
  _proto.parse = function parse(cfg) {
    this.$d = parseDate(cfg);
    this.$x = cfg.x || {};
    this.init();
  };
  _proto.init = function init() {
    var $d = this.$d;
    this.$y = $d.getFullYear();
    this.$M = $d.getMonth();
    this.$D = $d.getDate();
    this.$W = $d.getDay();
    this.$H = $d.getHours();
    this.$m = $d.getMinutes();
    this.$s = $d.getSeconds();
    this.$ms = $d.getMilliseconds();
  };
  _proto.$utils = function $utils() {
    return Utils;
  };
  _proto.isValid = function isValid() {
    return !(this.$d.toString() === INVALID_DATE_STRING);
  };
  _proto.isSame = function isSame(that, units) {
    var other = dayjs(that);
    return this.startOf(units) <= other && other <= this.endOf(units);
  };
  _proto.isAfter = function isAfter(that, units) {
    return dayjs(that) < this.startOf(units);
  };
  _proto.isBefore = function isBefore(that, units) {
    return this.endOf(units) < dayjs(that);
  };
  _proto.$g = function $g(input, get, set) {
    if (Utils.u(input))
      return this[get];
    return this.set(set, input);
  };
  _proto.unix = function unix() {
    return Math.floor(this.valueOf() / 1e3);
  };
  _proto.valueOf = function valueOf() {
    return this.$d.getTime();
  };
  _proto.startOf = function startOf(units, _startOf) {
    var _this = this;
    var isStartOf = !Utils.u(_startOf) ? _startOf : true;
    var unit = Utils.p(units);
    var instanceFactory = function instanceFactory2(d, m) {
      var ins = Utils.w(_this.$u ? Date.UTC(_this.$y, m, d) : new Date(_this.$y, m, d), _this);
      return isStartOf ? ins : ins.endOf(D);
    };
    var instanceFactorySet = function instanceFactorySet2(method, slice) {
      var argumentStart = [0, 0, 0, 0];
      var argumentEnd = [23, 59, 59, 999];
      return Utils.w(_this.toDate()[method].apply(
        _this.toDate("s"),
        (isStartOf ? argumentStart : argumentEnd).slice(slice)
      ), _this);
    };
    var $W = this.$W, $M = this.$M, $D = this.$D;
    var utcPad = "set" + (this.$u ? "UTC" : "");
    switch (unit) {
      case Y:
        return isStartOf ? instanceFactory(1, 0) : instanceFactory(31, 11);
      case M:
        return isStartOf ? instanceFactory(1, $M) : instanceFactory(0, $M + 1);
      case W: {
        var weekStart = this.$locale().weekStart || 0;
        var gap = ($W < weekStart ? $W + 7 : $W) - weekStart;
        return instanceFactory(isStartOf ? $D - gap : $D + (6 - gap), $M);
      }
      case D:
      case DATE:
        return instanceFactorySet(utcPad + "Hours", 0);
      case H:
        return instanceFactorySet(utcPad + "Minutes", 1);
      case MIN:
        return instanceFactorySet(utcPad + "Seconds", 2);
      case S:
        return instanceFactorySet(utcPad + "Milliseconds", 3);
      default:
        return this.clone();
    }
  };
  _proto.endOf = function endOf(arg) {
    return this.startOf(arg, false);
  };
  _proto.$set = function $set(units, _int) {
    var _C$D$C$DATE$C$M$C$Y$C;
    var unit = Utils.p(units);
    var utcPad = "set" + (this.$u ? "UTC" : "");
    var name = (_C$D$C$DATE$C$M$C$Y$C = {}, _C$D$C$DATE$C$M$C$Y$C[D] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[DATE] = utcPad + "Date", _C$D$C$DATE$C$M$C$Y$C[M] = utcPad + "Month", _C$D$C$DATE$C$M$C$Y$C[Y] = utcPad + "FullYear", _C$D$C$DATE$C$M$C$Y$C[H] = utcPad + "Hours", _C$D$C$DATE$C$M$C$Y$C[MIN] = utcPad + "Minutes", _C$D$C$DATE$C$M$C$Y$C[S] = utcPad + "Seconds", _C$D$C$DATE$C$M$C$Y$C[MS] = utcPad + "Milliseconds", _C$D$C$DATE$C$M$C$Y$C)[unit];
    var arg = unit === D ? this.$D + (_int - this.$W) : _int;
    if (unit === M || unit === Y) {
      var date = this.clone().set(DATE, 1);
      date.$d[name](arg);
      date.init();
      this.$d = date.set(DATE, Math.min(this.$D, date.daysInMonth())).$d;
    } else if (name)
      this.$d[name](arg);
    this.init();
    return this;
  };
  _proto.set = function set(string, _int2) {
    return this.clone().$set(string, _int2);
  };
  _proto.get = function get(unit) {
    return this[Utils.p(unit)]();
  };
  _proto.add = function add(number, units) {
    var _this2 = this, _C$MIN$C$H$C$S$unit;
    number = Number(number);
    var unit = Utils.p(units);
    var instanceFactorySet = function instanceFactorySet2(n) {
      var d = dayjs(_this2);
      return Utils.w(d.date(d.date() + Math.round(n * number)), _this2);
    };
    if (unit === M) {
      return this.set(M, this.$M + number);
    }
    if (unit === Y) {
      return this.set(Y, this.$y + number);
    }
    if (unit === D) {
      return instanceFactorySet(1);
    }
    if (unit === W) {
      return instanceFactorySet(7);
    }
    var step = (_C$MIN$C$H$C$S$unit = {}, _C$MIN$C$H$C$S$unit[MIN] = MILLISECONDS_A_MINUTE, _C$MIN$C$H$C$S$unit[H] = MILLISECONDS_A_HOUR, _C$MIN$C$H$C$S$unit[S] = MILLISECONDS_A_SECOND, _C$MIN$C$H$C$S$unit)[unit] || 1;
    var nextTimeStamp = this.$d.getTime() + number * step;
    return Utils.w(nextTimeStamp, this);
  };
  _proto.subtract = function subtract(number, string) {
    return this.add(number * -1, string);
  };
  _proto.format = function format(formatStr) {
    var _this3 = this;
    var locale = this.$locale();
    if (!this.isValid())
      return locale.invalidDate || INVALID_DATE_STRING;
    var str = formatStr || FORMAT_DEFAULT;
    var zoneStr = Utils.z(this);
    var $H = this.$H, $m = this.$m, $M = this.$M;
    var weekdays = locale.weekdays, months = locale.months, meridiem = locale.meridiem;
    var getShort = function getShort2(arr, index2, full, length) {
      return arr && (arr[index2] || arr(_this3, str)) || full[index2].slice(0, length);
    };
    var get$H = function get$H2(num) {
      return Utils.s($H % 12 || 12, num, "0");
    };
    var meridiemFunc = meridiem || function(hour, minute, isLowercase) {
      var m = hour < 12 ? "AM" : "PM";
      return isLowercase ? m.toLowerCase() : m;
    };
    var matches = {
      YY: String(this.$y).slice(-2),
      YYYY: this.$y,
      M: $M + 1,
      MM: Utils.s($M + 1, 2, "0"),
      MMM: getShort(locale.monthsShort, $M, months, 3),
      MMMM: getShort(months, $M),
      D: this.$D,
      DD: Utils.s(this.$D, 2, "0"),
      d: String(this.$W),
      dd: getShort(locale.weekdaysMin, this.$W, weekdays, 2),
      ddd: getShort(locale.weekdaysShort, this.$W, weekdays, 3),
      dddd: weekdays[this.$W],
      H: String($H),
      HH: Utils.s($H, 2, "0"),
      h: get$H(1),
      hh: get$H(2),
      a: meridiemFunc($H, $m, true),
      A: meridiemFunc($H, $m, false),
      m: String($m),
      mm: Utils.s($m, 2, "0"),
      s: String(this.$s),
      ss: Utils.s(this.$s, 2, "0"),
      SSS: Utils.s(this.$ms, 3, "0"),
      Z: zoneStr
    };
    return str.replace(REGEX_FORMAT, function(match, $1) {
      return $1 || matches[match] || zoneStr.replace(":", "");
    });
  };
  _proto.utcOffset = function utcOffset() {
    return -Math.round(this.$d.getTimezoneOffset() / 15) * 15;
  };
  _proto.diff = function diff(input, units, _float) {
    var _C$Y$C$M$C$Q$C$W$C$D$;
    var unit = Utils.p(units);
    var that = dayjs(input);
    var zoneDelta = (that.utcOffset() - this.utcOffset()) * MILLISECONDS_A_MINUTE;
    var diff2 = this - that;
    var result = Utils.m(this, that);
    result = (_C$Y$C$M$C$Q$C$W$C$D$ = {}, _C$Y$C$M$C$Q$C$W$C$D$[Y] = result / 12, _C$Y$C$M$C$Q$C$W$C$D$[M] = result, _C$Y$C$M$C$Q$C$W$C$D$[Q] = result / 3, _C$Y$C$M$C$Q$C$W$C$D$[W] = (diff2 - zoneDelta) / MILLISECONDS_A_WEEK, _C$Y$C$M$C$Q$C$W$C$D$[D] = (diff2 - zoneDelta) / MILLISECONDS_A_DAY, _C$Y$C$M$C$Q$C$W$C$D$[H] = diff2 / MILLISECONDS_A_HOUR, _C$Y$C$M$C$Q$C$W$C$D$[MIN] = diff2 / MILLISECONDS_A_MINUTE, _C$Y$C$M$C$Q$C$W$C$D$[S] = diff2 / MILLISECONDS_A_SECOND, _C$Y$C$M$C$Q$C$W$C$D$)[unit] || diff2;
    return _float ? result : Utils.a(result);
  };
  _proto.daysInMonth = function daysInMonth() {
    return this.endOf(M).$D;
  };
  _proto.$locale = function $locale() {
    return Ls[this.$L];
  };
  _proto.locale = function locale(preset, object) {
    if (!preset)
      return this.$L;
    var that = this.clone();
    var nextLocaleName = parseLocale(preset, object, true);
    if (nextLocaleName)
      that.$L = nextLocaleName;
    return that;
  };
  _proto.clone = function clone() {
    return Utils.w(this.$d, this);
  };
  _proto.toDate = function toDate() {
    return new Date(this.valueOf());
  };
  _proto.toJSON = function toJSON() {
    return this.isValid() ? this.toISOString() : null;
  };
  _proto.toISOString = function toISOString() {
    return this.$d.toISOString();
  };
  _proto.toString = function toString() {
    return this.$d.toUTCString();
  };
  return Dayjs2;
}();
var proto = Dayjs.prototype;
dayjs.prototype = proto;
[["$ms", MS], ["$s", S], ["$m", MIN], ["$H", H], ["$W", D], ["$M", M], ["$y", Y], ["$D", DATE]].forEach(function(g) {
  proto[g[1]] = function(input) {
    return this.$g(input, g[0], g[1]);
  };
});
dayjs.extend = function(plugin, option) {
  if (!plugin.$i) {
    plugin(option, Dayjs, dayjs);
    plugin.$i = true;
  }
  return dayjs;
};
dayjs.locale = parseLocale;
dayjs.isDayjs = isDayjs;
dayjs.unix = function(timestamp) {
  return dayjs(timestamp * 1e3);
};
dayjs.en = Ls[L];
dayjs.Ls = Ls;
dayjs.p = {};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var isBetween$1 = { exports: {} };
(function(module, exports) {
  !function(e, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    return function(e, i, t) {
      i.prototype.isBetween = function(e2, i2, s, f) {
        var n = t(e2), o = t(i2), r = "(" === (f = f || "()")[0], u = ")" === f[1];
        return (r ? this.isAfter(n, s) : !this.isBefore(n, s)) && (u ? this.isBefore(o, s) : !this.isAfter(o, s)) || (r ? this.isBefore(n, s) : !this.isAfter(n, s)) && (u ? this.isAfter(o, s) : !this.isBefore(o, s));
      };
    };
  });
})(isBetween$1);
var isBetween = isBetween$1.exports;
const _hoisted_1$5 = ["onClick"];
const _hoisted_2$3 = ["onClick"];
const _hoisted_3$2 = ["onClick"];
const _hoisted_4$1 = ["onClick"];
const _hoisted_5$1 = ["onClick"];
const _hoisted_6 = { class: "time-select-popup" };
const _hoisted_7 = { class: "top" };
const _hoisted_8 = {
  class: "left relative",
  id: "left"
};
const _hoisted_9 = ["onClick"];
const _hoisted_10 = { class: "right" };
const _hoisted_11 = ["onClick"];
const _hoisted_12 = ["onClick"];
const _hoisted_13 = {
  key: 0,
  class: "months"
};
const __default__$5 = {
  name: "GTimePicker"
};
const _sfc_main$7 = /* @__PURE__ */ Object.assign(__default__$5, {
  props: {
    modelValue: {},
    placeholder: {
      type: String,
      default: "\u6642\u9593: "
    },
    format: {
      type: String,
      default: "YYYY-MM-DD HH:mm"
    },
    width: {
      type: Number,
      default: 180
    },
    autoHideLabel: {
      type: Boolean,
      default: true
    },
    rangeSelectMode: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const props = __props;
    dayjs.extend(isBetween);
    const timeRangeFormat = "YYYY-MM-DD";
    const rangeSelectResult = ref("");
    const { format, width, rangeSelectMode, modelValue } = toRefs(props);
    const root = shallowRef();
    const isSelect = ref(false);
    const isMouseIn = ref(false);
    const isTimePickerShow = ref(false);
    const isHourPickerShow = ref(false);
    const curSelect = modelValue.value === null || modelValue.value === void 0 ? rangeSelectMode.value ? ref([null, null]) : ref(null) : ref(dayjs(modelValue.value));
    const curDay = ref(dayjs());
    const curDayIndex = rangeSelectMode.value ? ref([null, null]) : ref(null);
    const curCalenderInfo = reactive({
      curMonthDayStartIndex: null,
      curMonthDayEndIndex: null
    });
    const placeholderShow = computed(() => {
      let result = "";
      if (props.autoHideLabel) {
        if (modelValue.value === null || modelValue.value === "" || modelValue.value === void 0) {
          result = props.placeholder;
        }
      } else {
        result = props.placeholder;
      }
      return result;
    });
    watch(
      () => rangeSelectMode.value ? [curSelect.value[0], curSelect.value[1]] : curSelect.value,
      (val, oldVal) => {
        if (!rangeSelectMode.value) {
          emit(
            "update:modelValue",
            curSelect.value ? curSelect.value.format(format.value) : null
          );
        } else {
          if (!curSelect.value[0] && !curSelect.value[1]) {
            rangeSelectResult.value = "";
            emit("update:modelValue", "");
          }
          if (curSelect.value[0] && !curSelect.value[1]) {
            curSelect.value = [curSelect.value[0], curSelect.value[0]];
          }
          if (curSelect.value[0] && curSelect.value[1]) {
            let needReverse = curSelect.value[1].isBefore(
              curSelect.value[0].format(timeRangeFormat),
              "day"
            );
            let emitVal = needReverse ? `${curSelect.value[1].format(
              timeRangeFormat
            )} - ${curSelect.value[0].format(timeRangeFormat)}` : `${curSelect.value[0].format(
              timeRangeFormat
            )} - ${curSelect.value[1].format(timeRangeFormat)}`;
            rangeSelectResult.value = emitVal;
            emit("update:modelValue", emitVal);
          }
        }
      }
    );
    const eventHandle = () => {
      isTimePickerShow.value = false;
    };
    watch(
      () => isTimePickerShow.value,
      (val, oldVal) => {
        var _a2;
        isHourPickerShow.value = false;
        isSelect.value = true;
        if (val && document.getElementsByTagName("html")[0]) {
          document.getElementsByTagName("html")[0].addEventListener("click", eventHandle, false);
        } else {
          (_a2 = document.getElementsByTagName("html")[0]) == null ? void 0 : _a2.removeEventListener("click", eventHandle);
        }
      }
    );
    const monthAll = computed(() => {
      return curDay.value ? `${curDay.value.$y}\u5E74${curDay.value.$M + 1}\u6708` : "";
    });
    const isMonthAllShow = ref(false);
    const weekDays = ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"];
    const months = [
      "1\u6708",
      "2\u6708",
      "3\u6708",
      "4\u6708",
      "5\u6708",
      "6\u6708",
      "7\u6708",
      "8\u6708",
      "9\u6708",
      "10\u6708",
      "11\u6708",
      "12\u6708"
    ];
    const hours = new Array(24).fill("").map((i, idx) => idx);
    const minutes = new Array(60).fill("").map((i, idx) => idx);
    const curHourIndex = ref(hours.findIndex((ele) => ele == curDay.value.$H));
    const curMinuteIndex = ref(minutes.findIndex((ele) => ele == curDay.value.$m));
    const calenderDaysInfo = ref([]);
    const calenderDays = computed(() => {
      curCalenderInfo.curMonthDayStartIndex = null;
      curCalenderInfo.curMonthDayEndIndex = null;
      let arr = new Array(42);
      if (curDay.value) {
        let { $y: year, $M: month, $D: day, $W: weekday } = curDay.value;
        let { $W: monthStartDayWeekday } = dayjs(new Date(year, month, 1));
        let { $D: preMonthLastday, $M: preMonth } = dayjs(
          new Date(year, month, 1)
        ).subtract(1, "day");
        let { $D: monthEndDay, $W: monthEndWeekday } = dayjs(
          new Date(month == 11 ? year + 1 : year, month == 11 ? 0 : month + 1, 1)
        ).subtract(1, "day");
        let rowOnediff = monthStartDayWeekday;
        let rowLastPlus = monthEndWeekday == 6 ? 7 : 7 - monthEndWeekday;
        let idx2 = 0;
        for (let index2 = 0; index2 < 42; index2++) {
          if (rowOnediff - index2 > 0) {
            let day2 = preMonthLastday - rowOnediff + 1 + index2;
            arr[index2] = day2;
            calenderDaysInfo.value[index2] = dayjs(new Date(year, preMonth, day2));
          } else if (index2 < 42 - rowLastPlus + 1 && 1 + index2 - rowOnediff <= monthEndDay) {
            if (!curCalenderInfo.curMonthDayStartIndex) {
              curCalenderInfo.curMonthDayStartIndex = index2;
            }
            let day2 = 1 + index2 - rowOnediff;
            arr[index2] = day2;
            calenderDaysInfo.value[index2] = dayjs(new Date(year, month, day2));
          } else {
            if (!curCalenderInfo.curMonthDayEndIndex) {
              curCalenderInfo.curMonthDayEndIndex = index2;
            }
            let day2 = 1 + idx2;
            arr[index2] = day2;
            calenderDaysInfo.value[index2] = dayjs(new Date(year, month, day2)).add(
              1,
              "month"
            );
            idx2++;
          }
        }
      }
      return arr;
    });
    const getCalenderClass = (cdStr, idx) => {
      var _a2, _b, _c, _d, _e;
      let rowClass = "calDay-r-" + parseInt(idx / 7) + " calDay-c-" + idx % 7;
      if (rangeSelectMode.value && (((_a2 = curSelect.value[0]) == null ? void 0 : _a2.isSame(calenderDaysInfo.value[idx], "day")) || ((_b = curSelect.value[1]) == null ? void 0 : _b.isSame(calenderDaysInfo.value[idx], "day")))) {
        rowClass += " curSelect";
      }
      if (rangeSelectMode.value && curSelect.value[0] && curSelect.value[1] && dayjs(calenderDaysInfo.value[idx]).isBetween(
        (_c = curSelect.value[0]) == null ? void 0 : _c.format(timeRangeFormat),
        (_d = curSelect.value[1]) == null ? void 0 : _d.format(timeRangeFormat),
        "day",
        ")"
      )) {
        rowClass += " curSelectRange";
      }
      if (curDayIndex.value != null && idx == curDayIndex.value && !rangeSelectMode.value) {
        rowClass += " curSelect";
      }
      if (idx < 7 && parseInt(cdStr) > 16 || idx > 21 && parseInt(cdStr) < 16) {
        return `${rowClass} gray0`;
      }
      if (cdStr == ((_e = curDay.value) == null ? void 0 : _e.$D)) {
        return `${rowClass} today`;
      }
      return `${rowClass} gray1`;
    };
    const handleCalDayClick = (idx) => {
      let month = idx < curCalenderInfo.curMonthDayStartIndex ? curDay.value.$M - 1 < 0 ? 11 : curDay.value.$M - 1 : idx >= curCalenderInfo.curMonthDayEndIndex ? curDay.value.$M + 1 > 11 ? 0 : curDay.value.$M + 1 : curDay.value.$M;
      let year = curDay.value.$M == 11 && idx >= curCalenderInfo.curMonthDayEndIndex ? curDay.value.$y + 1 : curDay.value.$M == 0 && idx < curCalenderInfo.curMonthDayStartIndex ? curDay.value.$y - 1 : curDay.value.$y;
      let selectTime = new Date(
        year,
        month,
        calenderDays.value[idx],
        curHourIndex.value ? hours[curHourIndex.value] : 0,
        curMinuteIndex.value ? minutes[curMinuteIndex.value] : 0
      );
      if (rangeSelectMode.value) {
        if (!curSelect.value[0]) {
          curSelect.value[0] = dayjs(calenderDaysInfo.value[idx]);
        } else if (!curSelect.value[1]) {
          curSelect.value[1] = dayjs(calenderDaysInfo.value[idx]);
        } else if (curSelect.value[0] == curSelect.value[1]) {
          curSelect.value[1] = dayjs(calenderDaysInfo.value[idx]);
        } else {
          curSelect.value = [null, null];
        }
      }
      if (!rangeSelectMode.value) {
        curSelect.value = dayjs(selectTime);
        curDayIndex.value = idx;
      }
    };
    const handleMonthPre = () => {
      if (!rangeSelectMode.value) {
        curDayIndex.value = null;
      }
      curDay.value = dayjs(
        new Date(
          curDay.value.$M == 0 ? curDay.value.$y - 1 : curDay.value.$y,
          curDay.value.$M == 0 ? 11 : curDay.value.$M - 1,
          1
        )
      );
    };
    const handleMonthNext = () => {
      if (!rangeSelectMode.value) {
        curDayIndex.value = null;
      }
      curDay.value = dayjs(
        new Date(
          curDay.value.$M == 11 ? curDay.value.$y + 1 : curDay.value.$y,
          curDay.value.$M == 11 ? 0 : curDay.value.$M + 1,
          1
        )
      );
    };
    const handleMonthAll = () => {
      isMonthAllShow.value = !isMonthAllShow.value;
    };
    const handleMonthChange = (month) => {
      if (!rangeSelectMode.value) {
        curDayIndex.value = null;
      }
      if (month == "current") {
        isMonthAllShow.value = !isMonthAllShow.value;
        return true;
      }
      curDay.value = dayjs(new Date(curDay.value.$y, month, 1));
      isMonthAllShow.value = !isMonthAllShow.value;
    };
    const handleUseNow = () => {
      if (!rangeSelectMode.value) {
        curDay.value = dayjs();
        curSelect.value = dayjs();
        curHourIndex.value = hours.findIndex((ele) => ele == curDay.value.$H);
        curMinuteIndex.value = minutes.findIndex((ele) => ele == curDay.value.$m);
        calenderDays.value.forEach((day, idx) => {
          if (day == curDay.value.$D && idx >= curCalenderInfo.curMonthDayStartIndex && idx < curCalenderInfo.curMonthDayEndIndex) {
            curDayIndex.value = idx;
          }
        });
      }
    };
    const { right: rootRight } = useElementBounding(root);
    const { width: winWidth } = useWindowSize();
    const popupStyleComputed = computed(() => {
      if (root) {
        return {
          top: 42 + "px",
          left: rootRight.value + 100 > winWidth.value ? "-110px" : 0 + "px"
        };
      } else {
        return {};
      }
    });
    const popupClassComputed = computed(() => {
      let arr = [];
      if (isSelect.value) {
        arr.push(
          isTimePickerShow.value ? "tp-aniInTimepicker" : "tp-aniOutTimepicker"
        );
      }
      if (rangeSelectMode.value) {
        arr.push("rangeSelectMode");
      }
      return arr;
    });
    const handleHourMinuteChange = (target, value, idx) => {
      if (!rangeSelectMode.value) {
        switch (target) {
          case "hour": {
            curSelect.value = curSelect.value.hour(value);
            curHourIndex.value = idx;
            break;
          }
          case "minute": {
            curSelect.value = curSelect.value.minute(value);
            curMinuteIndex.value = idx;
            break;
          }
        }
      }
    };
    const handleTimePick = () => {
      isHourPickerShow.value = !isHourPickerShow.value;
    };
    return (_ctx, _cache) => {
      var _a2, _b;
      const _component_g_icon = resolveComponent("g-icon");
      const _component_g_button = resolveComponent("g-button");
      return openBlock(), createElementBlock("div", {
        ref_key: "root",
        ref: root,
        class: "gt-timepicker-box gt-input-wrapper"
      }, [
        createElementVNode("span", {
          class: normalizeClass([
            "gt-time-input",
            isTimePickerShow.value ? "open" : isSelect.value ? "selected" : isMouseIn.value ? "hover" : ""
          ]),
          style: normalizeStyle({ width: `${unref(width)}px` }),
          onMouseenter: _cache[0] || (_cache[0] = ($event) => isMouseIn.value = true),
          onMouseleave: _cache[1] || (_cache[1] = ($event) => isMouseIn.value = false),
          onClick: _cache[2] || (_cache[2] = withModifiers(($event) => isTimePickerShow.value = !isTimePickerShow.value, ["stop"]))
        }, [
          createTextVNode(toDisplayString(unref(placeholderShow)) + " ", 1),
          createElementVNode("span", null, toDisplayString(unref(rangeSelectMode) ? rangeSelectResult.value : (_a2 = unref(curSelect)) == null ? void 0 : _a2.format(unref(format))), 1)
        ], 38),
        createVNode(_component_g_icon, {
          class: "icon",
          name: "calendar",
          size: "sm",
          onClick: _cache[3] || (_cache[3] = withModifiers(($event) => isTimePickerShow.value = !isTimePickerShow.value, ["stop"]))
        }),
        createElementVNode("div", {
          onClick: _cache[6] || (_cache[6] = withModifiers(($event) => isHourPickerShow.value = false, ["stop"])),
          class: normalizeClass(["gt-timepicker", unref(popupClassComputed)]),
          style: normalizeStyle(unref(popupStyleComputed))
        }, [
          createElementVNode("div", {
            class: normalizeClass(["calender", unref(rangeSelectMode) ? "rangeSelectMode" : ""])
          }, [
            createElementVNode("span", {
              class: "month-pre",
              onClick: withModifiers(handleMonthPre, ["stop"])
            }, [
              createVNode(_component_g_icon, { name: "chevron-left" })
            ], 8, _hoisted_1$5),
            createElementVNode("p", {
              class: "month-all",
              onClick: withModifiers(handleMonthAll, ["stop"])
            }, toDisplayString(unref(monthAll)), 9, _hoisted_2$3),
            createElementVNode("span", {
              class: "month-next",
              onClick: withModifiers(handleMonthNext, ["stop"])
            }, [
              createVNode(_component_g_icon, { name: "chevron-right" })
            ], 8, _hoisted_3$2),
            !isMonthAllShow.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              (openBlock(), createElementBlock(Fragment, null, renderList(weekDays, (wdStr, idx) => {
                return createElementVNode("span", {
                  class: normalizeClass(`wdStr wdStr${idx}`),
                  key: idx + "bbb"
                }, toDisplayString(wdStr), 3);
              }), 64)),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(calenderDays), (cdStr, idx) => {
                return openBlock(), createElementBlock("span", {
                  class: normalizeClass(["calDay", getCalenderClass(cdStr, idx)]),
                  key: unref(v4)(),
                  onClick: withModifiers(
                    () => {
                      handleCalDayClick(idx);
                    },
                    ["stop"]
                  )
                }, toDisplayString(cdStr), 11, _hoisted_4$1);
              }), 128)),
              !unref(rangeSelectMode) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "time-select",
                onClick: withModifiers(handleTimePick, ["stop"])
              }, [
                createTextVNode(toDisplayString(!unref(rangeSelectMode) && unref(curSelect) ? (_b = unref(curSelect)) == null ? void 0 : _b.format("YYYY-MM-DD HH:mm").split(" ")[1] : "\u8ACB\u9078\u64C7\u6642\u9593") + " ", 1),
                withDirectives(createElementVNode("div", _hoisted_6, [
                  createElementVNode("div", _hoisted_7, [
                    createElementVNode("div", _hoisted_8, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(hours), (item, idx) => {
                        return openBlock(), createElementBlock("span", {
                          key: item + "h",
                          class: normalizeClass(idx == curHourIndex.value ? "current" : ""),
                          onClick: withModifiers(
                            () => {
                              handleHourMinuteChange("hour", item, idx);
                            },
                            ["stop"]
                          )
                        }, toDisplayString(item), 11, _hoisted_9);
                      }), 128))
                    ]),
                    createElementVNode("div", _hoisted_10, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(minutes), (item, idx) => {
                        return openBlock(), createElementBlock("span", {
                          key: item + "m",
                          class: normalizeClass(idx == curMinuteIndex.value ? "current" : ""),
                          onClick: withModifiers(
                            () => {
                              handleHourMinuteChange("minute", item, idx);
                            },
                            ["stop"]
                          )
                        }, toDisplayString(item), 11, _hoisted_11);
                      }), 128))
                    ])
                  ])
                ], 512), [
                  [vShow, isHourPickerShow.value]
                ])
              ], 8, _hoisted_5$1)) : createCommentVNode("", true),
              !unref(rangeSelectMode) ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: "use-cur-time",
                onClick: withModifiers(handleUseNow, ["stop"])
              }, "\u5957\u7528\u73FE\u5728\u6642\u9593", 8, _hoisted_12)) : createCommentVNode("", true),
              createElementVNode("span", {
                class: "comfirm",
                onClick: _cache[4] || (_cache[4] = withModifiers(($event) => isTimePickerShow.value = false, ["stop"]))
              }, "\u78BA\u5B9A")
            ], 64)) : createCommentVNode("", true)
          ], 2),
          isMonthAllShow.value ? (openBlock(), createElementBlock("div", _hoisted_13, [
            (openBlock(), createElementBlock(Fragment, null, renderList(months, (month, idx) => {
              return createElementVNode("span", {
                class: "month",
                key: month
              }, [
                curDay.value && idx != curDay.value.$M ? (openBlock(), createBlock(_component_g_button, {
                  key: 0,
                  pill: "",
                  type: "white",
                  onClick: withModifiers(
                    () => {
                      handleMonthChange(idx);
                    },
                    ["stop"]
                  )
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(month), 1)
                  ]),
                  _: 2
                }, 1032, ["onClick"])) : (openBlock(), createBlock(_component_g_button, {
                  key: 1,
                  pill: "",
                  onClick: _cache[5] || (_cache[5] = withModifiers(
                    () => {
                      handleMonthChange("current");
                    },
                    ["stop"]
                  ))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(month), 1)
                  ]),
                  _: 2
                }, 1024))
              ]);
            }), 64))
          ])) : createCommentVNode("", true)
        ], 6)
      ], 512);
    };
  }
});
_sfc_main$7.install = function(Vue) {
  Vue.component(_sfc_main$7.name, _sfc_main$7);
};
const _sfc_main$6 = {
  name: "GTimeline",
  setup(props, { slots, emit, expose }) {
    const validChilds = slots.default() ? slots.default().filter((item) => {
      return item.type.name == "GTimelineItem";
    }) : [];
    return () => h("div", { class: "gt-timeline-wrapper" }, validChilds);
  }
};
_sfc_main$6.install = function(Vue) {
  Vue.component(_sfc_main$6.name, _sfc_main$6);
};
const _hoisted_1$4 = { class: "gt-timeline-wrapper" };
const __default__$4 = {
  name: "GTimelineItem"
};
const _sfc_main$5 = /* @__PURE__ */ Object.assign(__default__$4, {
  props: {
    isEnd: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createElementVNode("div", {
          class: normalizeClass(["gt-timeline-item", __props.isEnd ? "end" : ""])
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ]);
    };
  }
});
_sfc_main$5.install = function(Vue) {
  Vue.component(_sfc_main$5.name, _sfc_main$5);
};
var tooltip_vue_vue_type_style_index_0_lang = "";
const __default__$3 = {
  name: "GTooltip"
};
const _sfc_main$4 = /* @__PURE__ */ Object.assign(__default__$3, {
  props: {
    position: {
      type: String,
      default: "right"
    }
  },
  setup(__props) {
    const props = __props;
    const popStyleComputed = computed(() => {
      let posi = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };
      switch (props.position) {
        case "right": {
          posi = {
            top: "0%",
            left: `calc(100% + 13px)`
          };
          break;
        }
        case "left": {
          posi = {
            top: "0%",
            right: `calc(100% + 13px)`
          };
          break;
        }
        case "top": {
          posi = {
            bottom: `calc(100% + 10px)`,
            left: "50%",
            transform: "translateX(-50%)"
          };
          break;
        }
        case "bottom": {
          posi = {
            top: `calc(100% + 10px)`,
            left: "50%",
            transform: "translateX(-50%)"
          };
          break;
        }
      }
      return posi;
    });
    const isShow = ref(false);
    const handleMouseover = (evt) => {
      isShow.value = true;
    };
    const handleMouseleave = (evt) => {
      isShow.value = false;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "gt-tooltip",
        onMouseover: handleMouseover,
        onMouseleave: handleMouseleave
      }, [
        renderSlot(_ctx.$slots, "default"),
        createElementVNode("div", {
          class: normalizeClass(["tooltip-popup", isShow.value ? [__props.position] : [__props.position, "none"]]),
          style: normalizeStyle(unref(popStyleComputed))
        }, [
          renderSlot(_ctx.$slots, "content")
        ], 6)
      ], 32);
    };
  }
});
_sfc_main$4.install = function(Vue) {
  Vue.component(_sfc_main$4.name, _sfc_main$4);
};
const _hoisted_1$3 = ["onClick"];
const _hoisted_2$2 = { class: "item-row" };
const _sfc_main$3 = {
  __name: "treeItem",
  props: {
    treeData: {
      type: Object,
      require: true
    }
  },
  setup(__props) {
    const props = __props;
    const componentKey = ref(0);
    const resetCurrentArea = inject("resetCurrentArea");
    const checkAll = inject("checkAll");
    const handleDownIcon = () => {
      let val = !props.treeData.collasped;
      props.treeData.collasped = val;
    };
    const handleClick = () => {
      if (props.treeData.clickCallBack) {
        props.treeData.clickCallBack();
      }
    };
    const handleItemClick = () => {
      let val = !props.treeData.isCurrentArea;
      resetCurrentArea();
      props.treeData["isCurrentArea"] = val;
    };
    watch(
      () => props.treeData.value,
      (val) => {
        if (props.treeData.children.length > 0) {
          checkAll(props.treeData.children, val, "value");
          componentKey.value = componentKey.value + 1;
        }
      }
    );
    return (_ctx, _cache) => {
      var _a2;
      const _component_g_icon = resolveComponent("g-icon");
      const _component_g_checkbox = resolveComponent("g-checkbox");
      const _component_tree_item = resolveComponent("tree-item", true);
      return openBlock(), createElementBlock("li", {
        class: normalizeClass(["gt-tree-item", __props.treeData.isCurrentArea ? "current" : ""]),
        key: componentKey.value,
        onClick: withModifiers(handleItemClick, ["stop"])
      }, [
        createElementVNode("div", _hoisted_2$2, [
          __props.treeData.children.length > 0 ? (openBlock(), createBlock(_component_g_icon, {
            key: 0,
            style: normalizeStyle({ transform: `rotate(${__props.treeData.collasped ? "-90" : "0"}deg)` }),
            name: "down",
            onClick: _cache[0] || (_cache[0] = withModifiers(
              () => {
                handleDownIcon(__props.treeData);
              },
              ["stop"]
            ))
          }, null, 8, ["style"])) : createCommentVNode("", true),
          createVNode(_component_g_checkbox, {
            modelValue: __props.treeData.value,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => __props.treeData.value = $event),
            label: __props.treeData.label,
            disabled: __props.treeData.disabled,
            onClick: _cache[2] || (_cache[2] = withModifiers(
              () => {
                handleClick(__props.treeData);
              },
              ["stop"]
            ))
          }, null, 8, ["modelValue", "label", "disabled"])
        ]),
        __props.treeData.children.length > 0 ? (openBlock(), createElementBlock("ul", {
          key: 0,
          class: normalizeClass(((_a2 = __props.treeData) == null ? void 0 : _a2.collasped) ? "collasped" : "active")
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.treeData.children, (item) => {
            return openBlock(), createBlock(_component_tree_item, {
              style: normalizeStyle({ "padding-left": item.children.length > 0 ? "21px" : "45px" }),
              treeData: item
            }, null, 8, ["style", "treeData"]);
          }), 256))
        ], 2)) : createCommentVNode("", true)
      ], 10, _hoisted_1$3);
    };
  }
};
const _hoisted_1$2 = { class: "gt-tree-wrapper" };
const __default__$2 = {
  name: "GTree"
};
const _sfc_main$2 = /* @__PURE__ */ Object.assign(__default__$2, {
  props: {
    data: {
      type: Array
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const genTree = (collection, level = 1) => {
      return collection.map((item) => {
        return {
          ...item,
          level,
          collasped: false,
          children: function() {
            return Array.isArray(item.children) ? genTree(item.children, level + 1) : [];
          }()
        };
      });
    };
    const dataRef = ref(Array.isArray(props.data) ? genTree(props.data) : []);
    const checkAll = (arr, value, attr) => {
      arr.forEach((item) => {
        item[attr] = value;
        if (item.children.length > 0) {
          checkAll(item.children, value, attr);
        }
      });
    };
    const resetCurrentArea = () => {
      checkAll(dataRef.value, false, "isCurrentArea");
    };
    provide("resetCurrentArea", resetCurrentArea);
    provide("checkAll", checkAll);
    expose({
      data: dataRef
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createElementVNode("ul", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(dataRef.value, (item, idx) => {
            return openBlock(), createBlock(_sfc_main$3, {
              key: `key-${idx}`,
              treeData: item
            }, null, 8, ["treeData"]);
          }), 128))
        ])
      ]);
    };
  }
});
_sfc_main$2.install = function(Vue) {
  Vue.component(_sfc_main$2.name, _sfc_main$2);
};
const _hoisted_1$1 = { class: "gt-upload-icon" };
const _hoisted_2$1 = /* @__PURE__ */ createElementVNode("div", { class: "inner" }, null, -1);
const _hoisted_3$1 = { class: "iconBox" };
const __default__$1 = {
  name: "GUploadIcon"
};
const _sfc_main$1 = /* @__PURE__ */ Object.assign(__default__$1, {
  props: {
    percent: {
      type: Number,
      default: 0
    },
    auto: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const { percent, auto } = __props;
    const percentNum = ref(percent);
    const styleComputed = computed(() => {
      return {
        background: `conic-gradient(#55585e 0 ${percentNum.value}%, #aaa 0 100%)`
      };
    });
    onMounted(() => {
      if (auto) {
        setInterval(() => {
          percentNum.value = percentNum.value + 10;
          if (percentNum.value > 100) {
            percentNum.value = 0;
          }
        }, 500);
      }
    });
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createElementVNode("div", {
          class: "pie",
          style: normalizeStyle(unref(styleComputed))
        }, null, 4),
        _hoisted_2$1,
        createElementVNode("div", _hoisted_3$1, [
          createVNode(_component_g_icon, { name: "upload" })
        ])
      ]);
    };
  }
});
_sfc_main$1.install = function(Vue) {
  Vue.component(_sfc_main$1.name, _sfc_main$1);
};
const _hoisted_1 = { class: "gt-pagination2" };
const _hoisted_2 = { class: "gt-flex" };
const _hoisted_3 = { class: "pageNums" };
const _hoisted_4 = ["onClick"];
const _hoisted_5 = ["onClick"];
const __default__ = {
  name: "GPagination2"
};
const _sfc_main = /* @__PURE__ */ Object.assign(__default__, {
  props: {
    pageSize: {
      type: Number,
      default: () => 10
    },
    pageCount: {
      type: Number,
      default: () => null
    },
    currentPage: {
      type: Number,
      default: () => 1
    },
    pagerCount: {
      type: Number,
      default: () => 7
    }
  },
  emits: [
    "update:page-size",
    "update:page-count",
    "update:current-page",
    "change"
  ],
  setup(__props, { emit }) {
    const props = __props;
    const { pageSize, pageCount, currentPage } = toRefs(props);
    const firstPage = ref(1);
    const lastPage = computed(() => {
      return pageCount.value ? Math.trunc(
        pageCount.value / pageSize.value + (pageCount.value % pageSize.value === 0 ? 0 : 1)
      ) : 1;
    });
    const list = computed(() => {
      let result = [
        {
          label: 1,
          type: "num",
          click: () => {
            handleCurrentPageChange(0, 1);
          }
        }
      ];
      if (currentPage.value - 3 > firstPage.value) {
        result.push({
          label: "ellipsis-1",
          icon: "ellipsis",
          type: "icon",
          click: () => {
            handleCurrentPageChange(-5);
          }
        });
      }
      let maxmin = [currentPage.value - 2, currentPage.value + 3];
      while (maxmin[0] < 2) {
        maxmin[0]++;
        maxmin[1]++;
      }
      while (maxmin[1] > lastPage.value) {
        if (maxmin[0] > firstPage.value) {
          maxmin[0]--;
        }
        maxmin[1]--;
      }
      for (let i = maxmin[0]; i < maxmin[1]; i++) {
        result.push({
          label: i,
          type: "num",
          click: () => {
            handleCurrentPageChange(0, i);
          }
        });
      }
      if (currentPage.value + 3 < lastPage.value) {
        result.push({
          label: "ellipsis-2",
          icon: "ellipsis",
          type: "icon",
          click: () => {
            handleCurrentPageChange(5);
          }
        });
      }
      result.push({
        label: lastPage.value,
        type: "num",
        click: () => {
          handleCurrentPageChange(0, lastPage.value);
        }
      });
      return result.filter((record, index2, self2) => {
        if (typeof record.label === "number") {
          return record.label >= index2 + 1;
        } else {
          return true;
        }
      });
    });
    const handleCurrentPageChange = (n, cp = null) => {
      let result = currentPage.value + n;
      if (result < firstPage.value) {
        result = firstPage.value;
      } else if (result > lastPage.value) {
        result = lastPage.value;
      }
      result = cp ? cp : result;
      emit("update:current-page", result);
      handleChange(result);
    };
    const handleChange = (v) => {
      emit("change", v);
    };
    return (_ctx, _cache) => {
      const _component_g_icon = resolveComponent("g-icon");
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createElementVNode("div", _hoisted_2, [
          createElementVNode("div", {
            class: normalizeClass(["pre-next pre", unref(currentPage) == firstPage.value ? "disable" : ""]),
            onClick: _cache[0] || (_cache[0] = () => {
              handleCurrentPageChange(-1);
            })
          }, [
            createVNode(_component_g_icon, {
              name: "chevron-left",
              class: "w-8"
            }),
            createTextVNode("\u4E0A\u4E00\u9801 ")
          ], 2),
          createElementVNode("div", _hoisted_3, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(list), (record, idx) => {
              return openBlock(), createElementBlock(Fragment, { key: idx }, [
                record.type === "num" ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["num", unref(currentPage) === record.label ? "current" : ""]),
                  onClick: record.click
                }, toDisplayString(record.label), 11, _hoisted_4)) : record.type === "icon" ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: "num dot",
                  onClick: record.click
                }, [
                  createVNode(_component_g_icon, {
                    name: record.icon,
                    size: "md"
                  }, null, 8, ["name"])
                ], 8, _hoisted_5)) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ]),
          createElementVNode("div", {
            class: normalizeClass(["pre-next next", unref(currentPage) == unref(lastPage) ? "disable" : ""]),
            onClick: _cache[1] || (_cache[1] = () => {
              handleCurrentPageChange(1);
            })
          }, [
            createTextVNode(" \u4E0B\u4E00\u9801"),
            createVNode(_component_g_icon, {
              name: "chevron-right",
              class: "w-8"
            })
          ], 2)
        ])
      ]);
    };
  }
});
_sfc_main.install = function(Vue) {
  Vue.component(_sfc_main.name, _sfc_main);
};
const components = [
  _sfc_main$M,
  _sfc_main$L,
  Checkbox,
  _sfc_main$G,
  _sfc_main$F,
  _sfc_main$D,
  _sfc_main$C,
  _sfc_main$B,
  _sfc_main$z,
  _sfc_main$A,
  _sfc_main$y,
  _sfc_main$x,
  _sfc_main$w,
  _sfc_main$J,
  _sfc_main$s,
  _sfc_main$r,
  _sfc_main$q,
  _sfc_main$p,
  _sfc_main$m,
  GLoadingIcon,
  _sfc_main$l,
  _sfc_main$k,
  _sfc_main$j,
  _sfc_main$i,
  _sfc_main$h,
  Radiobox,
  _sfc_main$e,
  _sfc_main$d,
  _sfc_main$c,
  _sfc_main$b,
  GTableColumn,
  _sfc_main$9,
  _sfc_main$n,
  _sfc_main$8,
  _sfc_main$7,
  _sfc_main$6,
  _sfc_main$5,
  _sfc_main$o,
  _sfc_main$4,
  _sfc_main$2,
  _sfc_main$1,
  _sfc_main
];
const install = function(Vue, opts = {}) {
  components.forEach((component) => {
    if (component.name && component.install) {
      Vue.component(component.name, component);
    } else {
      Object.values(component).forEach((comp) => {
        Vue.component(comp.name, comp);
      });
    }
  });
};
if (typeof window !== "undefined" && window.Vue) {
  install(window.Vue);
}
var index = {
  version: "1.4.0",
  install,
  Avatar: _sfc_main$M,
  Button: _sfc_main$L,
  Checkbox,
  CollapseCard: _sfc_main$G,
  CollapseCardSection: _sfc_main$F,
  Dialog: _sfc_main$D,
  Divider: _sfc_main$C,
  DownloadIcon: _sfc_main$B,
  Dropdown: _sfc_main$z,
  Dropdownitem: _sfc_main$A,
  FilterChips: _sfc_main$y,
  FilterChipsGroup: _sfc_main$x,
  Form: _sfc_main$w,
  Icon: _sfc_main$J,
  ImgUpload: _sfc_main$s,
  Input: _sfc_main$r,
  InputNumber: _sfc_main$q,
  Layout: _sfc_main$p,
  Loading: _sfc_main$m,
  LoadingIcon: GLoadingIcon,
  Menu: _sfc_main$l,
  Message: _sfc_main$k,
  MessageToast: _sfc_main$j,
  Option: _sfc_main$i,
  Pagination: _sfc_main$h,
  Radiobox,
  Select: _sfc_main$e,
  SortLabel: _sfc_main$d,
  Switch: _sfc_main$c,
  Table: _sfc_main$b,
  TableColumn: GTableColumn,
  Table2: _sfc_main$9,
  Tabs: _sfc_main$n,
  Tag: _sfc_main$8,
  TimePicker: _sfc_main$7,
  Timeline: _sfc_main$6,
  Timelineitem: _sfc_main$5,
  Title: _sfc_main$o,
  Tooltip: _sfc_main$4,
  Tree: _sfc_main$2,
  UploadIcon: _sfc_main$1,
  Pagination2: _sfc_main
};
export { index as default };
